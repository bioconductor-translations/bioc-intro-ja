---
source: Rmd
title: Manipulation et analyse de données avec dplyr
teaching: 75
exercises: 75
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- Décrire l'objectif des packages **`dplyr`** et **`tidyr`**.
- Décrire plusieurs fonctions extrêmement utiles pour manipuler des données.
- Décrire le concept d'un tableau large et long, et comment remodeler un tableau d'un format à l'autre.
- Montrer comment joindre des tables.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Analyse de données en R à l'aide du méta-package (paquet) tidyverse

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r loaddata_dplyr, echo=FALSE, purl=FALSE, message=FALSE}
if (!file.exists("data/rnaseq.csv"))
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv")
```

> Cet épisode est basé sur la leçon _Data Analysis and
> Visualisation in R for Ecologists_ de Data Carpentries.

## Manipulation des données avec **`dplyr`** et **`tidyr`**

Extraire un sous-ensemble avec les crochets est pratique, mais peut être fastidieux et difficile à lire, en particulier pour les opérations compliquées.

Certains packages peuvent grandement faciliter notre tâche lorsque nous manipulons des données.
Les packages dans R sont essentiellement des ensembles de fonctions supplémentaires qui vous permettent de faire plus de choses. Les fonctions que nous avons utilisées jusqu'à présent, comme `str()` ou
`data.frame()`, sont intégrées à R ; le chargement de packages donne accès à d'autres fonctions spécifiques. Avant d'utiliser un package pour la première fois, vous devez l'installer
sur votre machine, puis vous devez l'importer à chaque
session R suivante lorsque vous en avez besoin.

- Le package **`dplyr`** fournit des outils puissants pour les tâches de manipulation de données.
 Il est conçu pour fonctionner directement avec des data frames, avec de nombreuses tâches de manipulation optimisées.

- Comme nous le verrons plus loin, nous souhaitons parfois qu'un data frame soit remodelé pour pouvoir
 effectuer des analyses spécifiques ou pour la visualisation. Le package **`tidyr`** résout
 ce problème courant de remodelage des données et fournit des outils pour une manipulation _tidy_ des données, c'est-à-dire selon les principes du _tidyverse_.

Pour en savoir plus sur **`dplyr`** et **`tidyr`**, vous voudrez consulter l' aide-mémoire sur la transformation de données pratique avec
\*\*
et celui sur
.

- Le package **`tidyverse`** est un "package parapluie" qui installe
 plusieurs packages utiles pour l'analyse des données qui fonctionnent bien ensemble,
 tels que **`tidyr`**, \* \*`dplyr`\*\*, **`ggplot2`**, **`tibble`**, etc.
 Ces packages nous aident à travailler et à interagir avec les données.
 Ils nous permettent de faire beaucoup de choses avec nos données, comme en extraire des sous-ensembles, les transformer,
 les visualiser, etc.

Si vous avez configuré RStudio, vous devriez déjà avoir installé le package tidyverse.
Vérifiez si vous l'avez en essayant de le charger depuis la librarie (library) :

```{r load_dplyr, message=FALSE, purl=TRUE}
## load the tidyverse packages, incl. dplyr
library("tidyverse")
```

Si vous recevez un message d'erreur `aucun package nommé 'tidyverse' n'est trouvé` alors vous n'avez pas
installé le package pour cette version de R. Pour installer le package **`tidyverse`**, tapez :

```{r install_tidyverse, eval=FALSE, purl=TRUE}
BiocManager::install("tidyverse")
```

Si vous avez dû installer le package **`tidyverse`**, n'oubliez pas de le charger dans cette session R en utilisant la commande `library()` ci-dessus !

## Chargement de données avec le tidyverse

Au lieu d'utiliser la fonction `read.csv()`, nous allons lire nos données avec la fonction `read_csv()` (notez le `_` au lieu du `.`) du package **`readr`** du tidyverse.

```{r read_csv, message=FALSE, purl=TRUE}
rna <- read_csv("data/rnaseq.csv")

## view the data
rna
```

Notez que la classe de la variable est désormais appelée "tibble".

Les tibbles modifient certains comportements des objets data frame que nous avons introduits précédemment. La structure des données est très similaire à un data frame. Pour nos besoins, les seules différences sont les suivantes :

1. Il affiche le type de données de chaque colonne sous son nom.
 Notez que \<`dbl`\> est un type de données défini pour contenir des valeurs numériques décimales.

2. Il imprime uniquement les premières lignes de données et seulement les colonnes affichables à l'écran.

Nous allons maintenant apprendre les fonctions **`dplyr`** les plus courantes :

- `select()` : extraire des sous-ensembles de colonnes
- `filter()` : extraire des sous-ensembles de lignes
- `mutate()` : crée de nouvelles colonnes en utilisant les informations de colonnes préexistantes
- `group_by()` et `summarise()` : créent des statistiques récapitulatives sur des données groupées
- `arrange()` : trier les résultats
- `count()` : compte des valeurs discrètes

## Sélection de colonnes et filtrage de lignes

Pour sélectionner les colonnes d'un bloc de données, utilisez `select()`. Le premier argument
de cette fonction est le dataframe (`rna`), et les arguments
suivants reprennent les colonnes à conserver.

```{r select1, purl=TRUE}
select(rna, gene, sample, tissue, expression)
```

Pour sélectionner toutes les colonnes _sauf_ certaines, mettez un "-" devant
la variable à exclure.

```{r select2, purl=TRUE}
select(rna, -tissue, -organism)
```

Cela sélectionnera toutes les variables de `rna` sauf `tissue`
et `organism`.

Pour choisir des lignes en fonction d'un critère spécifique, utilisez `filter()` :

```{r filter1, purl=TRUE}
filter(rna, sex == "Male")
filter(rna, sex == "Male" & infection == "NonInfected")
```

Imaginons maintenant que nous nous intéressions aux homologues humains des gènes
de souris analysés dans ces données. Ces informations se trouvent dans la dernière colonne du tibble `rna`, nommée `hsapiens_homolog_associated_gene_name`.  Pour le visualiser facilement, nous
allons créer un nouveau tableau contenant uniquement les 2 colonnes `gene` et
`hsapiens_homolog_associated_gene_name`.

```{r select3}
genes <- select(rna, gene, hsapiens_homolog_associated_gene_name)
genes
```

Certains gènes de souris n'ont pas d'homologues humains. Ceux-ci peuvent être récupérés en utilisant
`filter()` et la fonction `is.na()`, qui détermine si
quelque chose est un `NA`.

```{r filter2, purl=TRUE}
filter(genes, is.na(hsapiens_homolog_associated_gene_name))
```

Si on veut conserver uniquement les gènes de souris qui ont un homologue humain, on peut utiliser "!" qui inverse le résultat logique pour demander chaque ligne où `hsapiens\_homolog\_associated\_gene\_name` _n'est pas_ un `NA`.

```{r, purl=TRUE}
filter(genes, !is.na(hsapiens_homolog_associated_gene_name))
```

## Pipes

Comment faire si vous souhaitez sélectionner et filtrer en même temps ? Il existe trois
façons de procéder : utiliser des étapes intermédiaires, des fonctions imbriquées ou des _pipes_.

Avec des étapes intermédiaires, vous créez un data frame temporaire et l'utilisez
comme entrée de la fonction suivante, comme ceci :

```{r pipemotiv1, purl=TRUE}
rna2 <- filter(rna, sex == "Male")
rna3 <- select(rna2, gene, sample, tissue, expression)
rna3
```

Ceci est lisible, mais peut encombrer votre espace de travail avec de nombreux
objets intermédiaires que vous devez nommer individuellement. Avec beaucoup d'étapes, cette approche devient difficile à suivre.

Vous pouvez également imbriquer des fonctions (c'est-à-dire une fonction dans une autre),
comme ceci :

```{r pipemotiv2, purl=TRUE}
rna3 <- select(filter(rna, sex == "Male"), gene, sample, tissue, expression)
rna3
```

Cette approche est pratique, mais peut être difficile à lire si trop de fonctions sont imbriquées, car R évalue l'expression de l'intérieur vers l'extérieur (dans ce cas, filtrer, puis sélectionner).

La dernière option, le _pipe_, est un ajout plus récent à R. Un _pipe_ permet de prendre
la sortie d'une fonction et de la passer directement à la suivante. Cette approche est utile
lorsque vous devez faire beaucoup d'opérations sur le même jeu de données.

Les _pipes_ dans R s'écrivent à `%>%` (mis à disposition via le package `magrittr`) ou `|>` (via R). Si vous utilisez RStudio, vous pouvez afficher un _pipe_ avec <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> sur un PC ou <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> sur un Mac.

Dans le code ci-dessus, nous utilisons le _pipe_ pour passer les données `rna` d'abord
dans `filter()` pour conserver les lignes où `sex` est égal à `"Male"`, puis dans `select()` pour conserver uniquement les colonnes `gene`, `sample`, `tissue` et `expression`.

Le _pipe_ `%>%` prend l'objet à sa gauche et le passe directement en tant que premier argument à la fonction à sa droite. Nous n'avons donc plus besoin d'inclure explicitement les données comme un argument pour les fonctions `filter()` et `select()`.

```{r usepipe, purl=TRUE}
rna |>
  filter(sex == "Male") |>
  select(gene, sample, tissue, expression)
```

Certains trouveront peut-être utile de lire le _pipe_ comme le mot "ensuite". Par exemple,
dans l'exemple ci-dessus, nous avons pris le data frame `rna`, _ensuite_ nous avons `filtré`
pour les lignes avec `sex == "Male"`, _ensuite_ nous avons sélectionné les colonnes `gene` `sample`, `tissue`, et `expression`.

Les fonctions de **`dplyr`** sont relativement simples, mais en les combinant avec le _pipe_, nous pouvons accomplir des manipulations plus complexes.

Si nous voulons créer un nouvel objet avec cette version plus petite des données, il suffit de
lui attribuer un nouveau nom :

```{r, purl=TRUE}
rna3 <- rna |>
  filter(sex == "Male") |>
  select(gene, sample, tissue, expression)

rna3
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

À l'aide de _pipes_, extraire un sous-ensemble de `rna` pour ne conserver que les observations des souris femelles au temps 0, où le gène a une expression supérieure à 50000, et ne conservez que les colonnes
`gene`, `sample `, `time`, `expression` et `age`.

:::::::::::::::  solution

## Solution

```{r}
rna |>
  filter(expression > 50000,
         sex == "Female",
         time == 0 ) |>
  select(gene, sample, time, expression, age)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Mutate

Vous souhaiterez fréquemment créer de nouvelles colonnes basées sur les valeurs des colonnes
existantes, par exemple pour effectuer des conversions d'unités ou pour trouver le rapport des valeurs dans deux colonnes
. Pour cela, nous utiliserons la fonction `mutate()`.

Pour créer une nouvelle colonne de temps en heures :

```{r, purl=TRUE}
rna |>
  mutate(time_hours = time * 24) |>
  select(time, time_hours)
```

Vous pouvez également créer une deuxième nouvelle colonne basée sur la première nouvelle colonne dans le même appel de `mutate()` :

```{r, purl=TRUE}
rna |>
  mutate(time_hours = time * 24,
         time_mn = time_hours * 60) |>
  select(time, time_hours, time_mn)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Créez un nouveau data frane à partir de `rna` qui répond aux critères
suivants : contient uniquement les colonnes `gene`, `chromosome_name`,
`phenotype_description`, `sample` et `expression`. Les valeurs d'expression
doivent être transformées en log. Ce data frame doit
contenir uniquement des gènes situés sur les chromosomes sexuels, ayant bien un `phenotype
\_description`, et une expression en log supérieure à 5.

**Astuce** : réfléchissez bien à la façon dont les commandes doivent être ordonnées !

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, purl=TRUE}
rna |>
  mutate(expression = log(expression)) |>
  select(gene, chromosome_name, phenotype_description, sample, expression) |>
  filter(chromosome_name == "X" | chromosome_name == "Y") |>
  filter(!is.na(phenotype_description)) |>
  filter(expression > 5)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Analyse de données "split-apply-combine"

De nombreuses tâches d'analyse de données peuvent être abordées à l'aide du paradigme
_split-apply-combine_ : divisez les données en groupes, appliquez une analyse
à chaque groupe, puis combinez les résultats. **`dplyr`**
rend cela très facile grâce à l'utilisation de la fonction `group_by()`.

```{r}
rna |>
  group_by(gene)
```

La fonction `group_by()` n'effectue aucun traitement de données, elle
regroupe simplement les données en sous-ensembles : dans l'exemple ci-dessus, notre
`tibble` initial de `r nrow(rna)` observations est divisé en
`r length(unique(rna$gene))` groupes selon la variable `gene`.

On pourrait de même décider de regrouper le tibble par échantillons :

```{r}
rna |>
  group_by(sample)
```

Ici, notre `tibble` initial de `r nrow(rna)` observations est divisé en
`r length(unique(rna$sample))` groupes selon la variable `sample`.

Une fois les données regroupées, les opérations qui suivent sont
appliquées sur chaque groupe indépendamment.

### La fonction `summarise()`

`group_by()` est souvent utilisé avec `summarise()`, qui
réduit chaque groupe en un résumé d'une seule ligne.

`group_by()` prend comme arguments les noms de colonnes qui contiennent les variables
**catégorielles** pour lesquelles vous souhaitez calculer les statistiques récapitulatives. Donc, pour calculer l'expression moyenne par gène :

```{r}
rna |>
  group_by(gene) |>
  summarise(mean_expression = mean(expression))
```

Nous pourrions également vouloir calculer les niveaux d’expression moyens de tous les gènes dans chaque échantillon :

```{r}
rna |>
  group_by(sample) |>
  summarise(mean_expression = mean(expression))
```

On peut également regrouper les observations par plusieurs colonnes :

```{r}
rna |>
  group_by(gene, infection, time) |>
  summarise(mean_expression = mean(expression))
```

Une fois les données regroupées, vous pouvez également résumer plusieurs variables en même temps
(et pas nécessairement sur la même variable). Par exemple, nous pourrions ajouter une colonne
indiquant l'expression médiane par gène et par condition :

```{r, purl=TRUE}
rna |>
  group_by(gene, infection, time) |>
  summarise(mean_expression = mean(expression),
            median_expression = median(expression))
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Calculer le niveau d’expression moyen du gène "Dok3" pour chaque temps.

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
rna |>
  filter(gene == "Dok3") |>
  group_by(time) |>
  summarise(mean = mean(expression))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Count

Lorsque nous travaillons avec des données, nous souhaitons souvent connaître le nombre d'observations trouvées
pour chaque facteur ou combinaison de facteurs. Pour cette tâche, **`dplyr`** fournit la fonction `count()`. Par exemple, si nous voulons compter le nombre d'observations pour
chaque échantillon infecté et non infecté :

```{r, purl=TRUE}
rna |>
    count(infection)
```

La fonction `count()` est un raccourci pour quelque chose que nous avons déjà vu : regrouper par une variable et la résumer en comptant le nombre d'observations dans ce groupe. En d'autres termes, `rna %>% count(infection)` équivaut à :

```{r, purl=TRUE}
rna |>
    group_by(infection) |>
    summarise(n = n())
```

L'exemple précédent montre l'utilisation de `count()` pour compter le nombre de lignes/observations
pour _un_ facteur (c'est-à-dire `infection`).
Pour compter une _combinaison de facteurs_, telle que `infection` et `time`,
il suffit de spécifier les deux facteurs comme arguments de `count()` :

```{r, purl=TRUE}
rna |>
    count(infection, time)
```

ce qui équivaut à ceci :

```{r, purl=TRUE}
rna |>
  group_by(infection, time) |>
  summarise(n = n())
```

Il est parfois utile de trier le résultat pour faciliter les comparaisons.
Nous pouvons utiliser `arrange()` pour trier le tableau.
Par exemple, nous pourrions vouloir organiser le tableau ci-dessus par temps :

```{r, purl=TRUE}
rna |>
  count(infection, time) |>
  arrange(time)
```

ou par comptage :

```{r, purl=TRUE}
rna |>
  count(infection, time) |>
  arrange(n)
```

Pour trier par ordre décroissant, nous devons ajouter la fonction `desc()` :

```{r, purl=TRUE}
rna |>
  count(infection, time) |>
  arrange(desc(n))
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

1. Combien de gènes ont été analysés dans chaque échantillon ?
2. Utilisez `group_by()` et `summarise()` pour évaluer la profondeur de séquençage (la somme de tous les comptes) dans chaque échantillon. Quel échantillon a la profondeur de séquençage la plus élevée ?
3. Choisissez un échantillon et évaluez le nombre de gènes par biotype.
4. Identifiez les gènes associés à la description du phénotype "abnormal DNA methylation" et calculez leur expression moyenne (en log) au temps 0, 4 et 8.

:::::::::::::::  solution

## Solution

```{r}
## 1.
rna |>
  count(sample)
## 2.
rna |>
  group_by(sample) |>
  summarise(seq_depth = sum(expression)) |>
  arrange(desc(seq_depth))
## 3.
rna |>
  filter(sample == "GSM2545336") |>
  count(gene_biotype) |>
  arrange(desc(n))
## 4.
rna |>
  filter(phenotype_description == "abnormal DNA methylation") |>
  group_by(gene, time) |>
  summarise(mean_expression = mean(log(expression))) |>
  arrange()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Remodeler les données

Dans le tibble `rna`, les lignes contiennent des valeurs d'expression qui sont associées à une combinaison de 2 autres variables : `gene` et `sample`.

Toutes les autres colonnes correspondent à des variables décrivant soit
l'échantillon (organisme, âge, sexe, ...) soit le gène ('gene_biotype', 'ENTREZ_ID', 'product', ...).
Les variables qui ne changent pas avec les gènes ou avec les échantillons auront la même valeur dans toutes les lignes.

```{r}
rna |>
  arrange(gene)
```

Cette structure est appelée "format long", car une colonne contient toutes les valeurs,
et d'autres colonnes répertorient le contexte de la valeur.

Dans certains cas, le "format long" n'est pas facile à lire, et un autre format, un "format large" est préféré, comme manière plus compacte de représenter les données.
Cela est typiquement le cas pour des données d'expression de gènes, qui sont généralement représentées sous forme de matrice où les gènes sont repris le long des lignes et les échantillons le long des colonnes.

Dans ce format, il devient donc simple
d'explorer la relation entre les niveaux d'expression génique au sein et
entre les échantillons.

```{r, echo=FALSE}
rna |>
  select(gene, sample, expression) |>
  pivot_wider(names_from = sample,
              values_from = expression)
```

Pour convertir les valeurs d'expression génique de `rna` en un format large,
nous devons créer une nouvelle table où les valeurs de la colonne `sample` deviendraient
les noms des variables de colonne.

Nous **remodellons** les données en fonction des observations d'intérêt, tout en continant à suivre les principles des données tidy: niveaux d'expression par gène au lieu des les afficher par gènes et par échantillons.

La transformation inverse serait de transformer les noms de colonnes en valeurs
d'une nouvelle variable.

Nous pouvons effectuer ces deux transformations avec deux fonctions du package `tidyr`, à savoir `pivot_longer()` et `pivot_wider()` (voir
[ici](https://tidyr.tidyverse.org /dev/articles/pivot.html) pour
détails).

### Pivoter les données en format large

Sélectionnons les 3 premières colonnes de `rna` et utilisons `pivot_wider()`
pour transformer les données en format large.

```{r, purl=TRUE}
rna_exp <- rna |>
  select(gene, sample, expression)
rna_exp
```

`pivot_wider` prend trois arguments principaux :

1. les données à transformer ;
2. le `names_from` : la colonne dont les valeurs deviendront les nouveaux noms de colonne ;
3. les `values_from` : la colonne dont les valeurs rempliront les nouvelles colonnes.

```{r, fig.cap="Grand pivot des données `rna`.", echo=FALSE, message=FALSE}
knitr::include_graphics("fig/pivot_wider.png")

```

```{r, purl=TRUE}
rna_wide <- rna_exp |>
  pivot_wider(names_from = sample,
              values_from = expression)
rna_wide
```

Notez que par défaut, la fonction `pivot_wider()` ajoutera `NA` pour les valeurs manquantes.

Imaginons que nous ayons des valeurs d'expression manquantes pour certains gènes
dans certains échantillons. Dans cet exemple, le gène Cyp2d22 n'aune donnée d'expression que pour l'echantillon GSM2545338.

```{r, purl=TRUE}
```

Par défaut, la fonction `pivot_wider()` ajoutera `NA` pour les valeurs
manquantes. Ceci peut être paramétré avec l'argument `values_fill` de
la fonction `pivot_wider()`.

```{r, purl=TRUE}
rna_with_missing_values %>%
  pivot_wider(names_from = échantillon,
              values_from = expression)

rna_with_missing_values %>%
  pivot_wider(names_from = échantillon,
              values_from = expression,
              valeurs_fill = 0)
```

### Pivoter les données en format long

Dans la situation inverse, nous utilisons les noms de colonnes et les transformons en deux nouvelles variables. Une variable représente le nom de colonne contenant les valeurs, et l'autre contenant les valeurs précédemment
associées aux noms de colonnes.

`pivot_longer()` prend quatre arguments principaux :

1. les données à transformer ;
2. `names_to` : le nouveau nom de colonne que nous souhaitons créer et remplir avec les
 noms de colonnes actuels ;
3. `values_to` : le nouveau nom de colonne que nous souhaitons créer et remplir avec
 valeurs actuelles ;
4. les noms des colonnes à utiliser pour renseigner les variables `names_to` et
 `values_to` (ou à ignorer).

``{r, fig.cap="Pivot long des données `rna`.", echo=FALSE, message=FALSE}
knitr::include_graphics("fig/pivot_longer.png")``

```

Pour créer `rna_long` à partir de `rna_wide`, nous créons une première variable `"sample"` qui conteindra les noms des échantillons repris comme noms de colonnes (hormi `gene`), et une seconde, `"expression"`, qui contiendra les valeurs de la table. Nous ommettons la colonne `gene` pour la transformation en y ajoutant le signe moins.

Notez que les nouveaux noms de colonnes sont repris entre guillemets.

```{r}
rna_long <- rna_wide %>%
    pivot_longer(names_to = "sample",
                 values_to = "expression",
                 -gene)
rna_long
```
```

Nous aurions également pu spécifier les colonnes à
inclure. Quand il faut inclure un grand nombre de colonnes, et il est plus facile de spécifier ce qu'il faut rassembler que ce qu'il faut ignorer. Ici, la fonction `starts_with()` peut aider à récupérer des colonnes
sans avoir à toutes les énumérer !
Une autre possibilité serait d'utiliser l'opérateur `:` !

```{r}
```{r}
rna_wide %>%
    pivot_longer(names_to = "sample",
                 values_to = "expression",
                 cols = start_with("GSM"))
rna_wide %> %
    pivot_longer(names_to = "sample",
                 valeurs_to = "expression",
                 GSM2545336:GSM2545380)
```
```

Notez que si nous avions des valeurs manquantes dans le format large, le `NA` serait
inclus dans le nouveau format long.

Souvenez-vous de notre précédent tibble fictif contenant des valeurs manquantes :

```{r}
```{r}
rna_with_missing_values

wide_with_NA <- rna_with_missing_values %>%
  pivot_wider(names_from = sample,
              values_from = expression)
wide_with_NA

wide_with_NA %>%
    pivot_longer(names_to = "sample",
                 values_to = "expression",
                 -gene)
```
```

Passer à des formats larges et longs peut être un moyen utile d'équilibrer un ensemble de données afin que chaque réplique ait la même composition.

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

A partir de la table `rna`, utilisez la fonction `pivot_wider()` pour créer un tableau au format large donnant les niveaux d'expression génique chez chaque souris.
Utilisez ensuite la fonction `pivot_longer()` pour restaurer le tableau au format long.

::::::::::::::: solution

## Solution

```{r, answer=TRUE, purl=TRUE}
```{r}
rna1 <- rna %>%
select(gene, mouse, expression) %>%
pivot_wider(names_from = mouse, values_from = expression)
rna1

rna1 %>%
pivot_longer(names_to = "mouse_id", values_to = "counts", -gene)
```
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

Extraire les gènes situés sur les chromosomes X et Y du data frame `rna` et
remodeler les données avec la variable `sex` en colonnes et la varibale `chromosome_name` en
lignes et l'expression moyenne des gènes localisés dans chaque chromosome comme valeurs,
comme dans le tableau suivant :

```{r, echo=FALSE, message=FALSE}
knitr::include_graphics("fig/Exercise_pivot_W.png")
```

Il faudra résumer avant de remodeler !

::::::::::::::: solution

## Solution

Calculons d'abord le niveau d'expression moyen des gènes des chromosomes X et Y pour les
échantillons mâles et femelles...

```{r}
 arn %>%
  filter(chromosome_name == "Y" | chromosome_name == "X") %>%
  group_by(sex, chromosome_name) %>%
  résumé(moyenne = moyenne(expression))
```

Et pivotons le tableau au format large

```{r, answer=TRUE, purl=TRUE}
rna_1 <- rna %>%
  filter(chromosome_name == "Y" | chromosome_name == "X") %>%
  group_by(sex, chromosome_name) %>%
  summarise(mean = moyenne(expression)) %>%
  pivot_wider(names_from = sexe,
              valeurs_from = moyenne)

rna_1
```

Maintenant, prenez cette trame de données et transformez-la avec `pivot_longer()` afin que
chaque ligne soit une combinaison unique de `chromosome_name` par `gender`.

```{r, answer=TRUE, purl=TRUE}
rna_1 %>%
  pivot_longer(names_to = "gender",
               valeurs_to = "mean",
               -chromosome_name)

```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

Utilisez l'ensemble de données `rna` pour créer une matrice d'expression où chaque ligne
représente les niveaux d'expression moyens des gènes et les colonnes représentent
les différents temps.

::::::::::::::: solution

## Solution

Calculons d'abord l'expression moyenne par gène et par temps

```{r}
arn %>%
  group_by(gène, temps) %>%
  résumé(mean_exp = moyenne(expression))
```

avant d'utiliser la fonction `pivot_wider()`

```{r}
rna_time <- rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp)
rna_time
```

Notez que cela génère un tibble avec certains noms de colonnes commençant par un nombre.
Si nous voulions sélectionner la colonne correspondant aux points temporels,
nous ne pourrions pas utiliser directement les noms des colonnes... Que se passe-t-il lorsque l'on sélectionne la colonne 4 ?

```{r}
rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp) |>
  select(gene, 4)
```

Pour sélectionner le temp 4, il faudrait citer le nom de la colonne, avec des _backticks_ "\\`"

```{r}
rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp) |>
  select(gene, `4`)
```

Une autre possibilité serait de renommer les colonnes,
en choisissant des noms qui ne commencent pas par un chiffre :

```{r}
rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp) |>
  rename("time0" = `0`, "time4" = `4`, "time8" = `8`) |>
  select(gene, time4)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

Utilisez le data frame précédent contenant les niveaux d'expression moyens par temps et créez
une nouvelle colonne contenant les _fold-changes_ entre les temps 8 et 0, et les temps 8 et 4.
Convertissez ce tableau en un tableau au format long regroupant les _fold-changes_ calculés.

::::::::::::::: solution

## Solution

À partir du tibble `rna_time` :

```{r}
arn_time
```

Calculer les _fold-changes_ :

```{r}
rna_time %>%
  muter (time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`)
```

Et utilisez la fonction `pivot_longer()` :

```{r}
rna_time |>
  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`) |>
  pivot_longer(names_to = "comparisons",
               values_to = "Fold_changes",
               time_8_vs_0:time_8_vs_4)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

## Jointures de tables

Dans de nombreuses situations réelles, les données sont réparties sur plusieurs tables.
Cela se produit généralement parce que différents types d’informations sont
collectés à partir de différentes sources.

Il peut être souhaitable que certaines analyses combinent les données de deux ou plusieurs tables
en un seul data frame basé sur une colonne commune
à toutes les tables.

Le package `dplyr` fournit un ensemble de fonctions de jointure pour combiner deux data frames
en fonction des correspondances entre les colonnes spécifiées. Ici, nous
fournissons une brève introduction aux jointures. Pour en savoir plus, veuillez
vous référer au chapitre sur les [jointures de table](https://uclouvain-cbio.github.io/WSBIM1207/sec-join.html). Le
Data Transformation Cheat
Sheet
fournit également un bref aperçu sur les jointures de table.

Nous allons illustrer la jointure en utilisant une petite table, `rna_mini` que
nous allons créer en extrayant de la table `rna` d'origine 3
colonnes et 10 lignes.

```{r}
rna_mini <- rna %>%
   select(gène, échantillon, expression) %>%
   head(10)
rna_mini
```

Le deuxième tableau, `annot1`, contient 2 colonnes, `gene` et
`gene_description`. Vous pouvez soit
[télécharger annot1.csv](https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv)
en cliquant sur le lien puis en déplaçant le fichier dans le dossier `data/`, ou
vous pouvez utiliser le code R ci-dessous pour le télécharger directement dans le dossier `data`.

```{r, message=FALSE}
download.file(url = "https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv",
              destfile = "data/annot1.csv")
annot1 <- read_csv(file = "data/annot1.csv")
annot1
```

Nous voulons maintenant joindre ces deux tables en une seule contenant toutes les
variables en utilisant la fonction `full_join()` du package `dplyr`. La fonction
trouvera automatiquement la variable commune correspondant aux colonnes
de la première et de la deuxième table.  Dans ce cas, `gene` est la seule variable commune. De telles variables sont appelées clés. Les clés sont utilisées pour faire correspondre les
observations dans différentes tables.

```{r}
full_join(rna_mini, annot1)
```

En recherche, les gènes sont parfois només différemment.

La table `annot2` est exactement la même que `annot1` sauf que la variable
contenant les noms de gènes est nommée différemment. Encore une fois,
[téléchargez annot2.csv](https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv)
vous-même et déplacez-le vers `data/ ` ou utilisez le code R ci-dessous.

```{r, message=FALSE}
download.file(url = "https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv",
              destfile = "data/annot2.csv")
annot2 <- read_csv(file = "data/annot2.csv")
annot2
```

Si aucun des noms de variables ne correspond, nous pouvons définir manuellement les variables
à utiliser pour la correspondance.  Ces variables peuvent être définies en utilisant
l'argument `by`, comme indiqué ci-dessous avec les tables `rna_mini` et `annot2`.

```{r}
full_join(rna_mini, annot2, by = c("gene" = "external_gene_name"))
```

Comme on peut le voir ci-dessus, le nom de variable de la première table est lors de la jointure.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Téléchargez la table `annot3` en cliquant
[ici](https://carpentries-incubator.github.io/bioc-intro/data/annot3.csv)
et placez la table dans votre dossier `data`.  À l'aide de la fonction `full_join()`, joignez les tables `rna_mini` et `annot3`. Que s'est-il passé pour les gènes
_Klk6_, _mt-Tf_, _mt-Rnr1_, _mt-Tv_, _mt-Rnr2_ et _mt-Tl1_ ?

:::::::::::::::  solution

## Solution

```{r, message=FALSE}
annot3 <- read_csv("data/annot3.csv")
full_join(rna_mini, annot3)
```

Les gènes _Klk6_ ne sont présents que dans `rna_mini`, tandis que les gènes _mt-Tf_, _mt-Rnr1_, _mt-Tv_,
_mt-Rnr2_ et _mt-Tl1_ sont présent uniquement dans la table `annot3`. Leurs valeurs respectives pour les variables
du tableau ont été codées comme manquantes.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Exporter des données

Maintenant que vous avez appris à utiliser `dplyr` pour extraire des informations de
ou résumer vos données, vous souhaiterez peut-être exporter ces nouveaux jeux de données pour les partager
avec vos collaborateurs ou pour les archiver.

Tout comme à la fonction `read_csv()` utilisée pour lire/importer les fichiers CSV dans R, il existe
une fonction `write_csv()` qui génère des fichiers CSV à partir de data frames.

Avant d'utiliser `write_csv()`, nous allons créer un nouveau dossier, `data_output`,
dans notre répertoire de travail, pour y sauvegarder nos nouveaux de données. Nous ne voulons pas
écrive les ensembles de données générés dans le même répertoire que nos données brutes.
C'est en effet une bonne pratique de les garder séparés. Le dossier `data` ne doit contenir que
les données brutes et non modifiées, et doit être laissé tel quel pour nous assurer que nous ne les supprimons ou modifions pas. En revanche, notre script générera le contenu du répertoire `data_output`, donc même si les fichiers qu'il contient sont supprimés, nous pourrons toujours
les regénérer.

Utilisons `write_csv()` pour sauvegarder la table `rna_wide` que nous avons créée précédemment.

```{r, purl=TRUE, eval=FALSE}
write_csv(rna_wide, file = "data_output/rna_wide.csv")
```

:::::::::::::::::::::::::::::::::::::::: keypoints

- Données tabulaires dans R utilisant le méta-package _tidyverse_.

::::::::::::::::::::::::::::::::::::::::::::::::::
