---
source: Rmd
title: Prochaines étapes
teaching: 45
exercises: 45
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- Présenter le projet Bioconductor.
- Introduire la notion de 'conteneurs' de données.
- Donner un aperçu du `SummarizedExperiment`, très fréquemment utilisé dans les analyses de données de type omiques.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Qu'est-ce qu'un « SummarizedExperiment » ?
- Qu’est-ce que Bioconductor ?

::::::::::::::::::::::::::::::::::::::::::::::::

## Prochaines étapes

```{r, echo=FALSE, message=FALSE}
bibliothèque("tidyverse")
```

Pour faciliter l'analyse des données omiques qui sont généralement complexes,  les développeurs ont défini des conteneurs spécialisés (appelés classes), spécifiquement adaptés à leurs  propriétés, afin de pouvoir les stocker et les manipuler facilement.

Cet aspect est central au projet **Bioconductor**[^Bioconductor]
qui utilise la même **infrastructure de données** dans tous ses _packages_. Il est en effet demandé aux développeurs de packages Bioconductor
d'utiliser l'infrastructure existante pour
assurer la cohérence, l'interopérabilité et la stabilité du projet dans son ensemble. Ceci
a d'ailleurs certainement contribué au succès de Bioconductor
. Ceci a d'ailleurs certainement contribué au succès de Bioconductor
.

[^Bioconductor]: Le [projet Bioconductor](https://www.bioconductor.org) a été
    initié par Robert Gentleman, l'un des deux créateurs du langage R
    . Bioconductor utilise le langage R pour fournir des outils dédiés à l'analyse des données omiques. Bioconductor est _open source_ et _open development_.

Pour illustrer la notion de **conteneur de données omiques**, nous présenterons la classe appelée
`SummarizedExperiment`.

## SummarizedExperiment

La figure ci-dessous représente la structure de cette classe.

```{r SE, echo=FALSE, out.width="80%"}
knitr::include_graphics("https://uclouvain-cbio.github.io/WSBIM1322/figs/SE.svg")
```

Les objets de la classe SummarizedExperiment contiennent :

- **Un (ou plusieurs) test(s)** contenant les données omiques quantitatives
  (données d'expression), stockées sous forme d'objet de type matriciel. dans lesquelles les lignes représentent les _features_ (les variables mesurées, comme par exemple les gènes dans le cas d'une analyse RNAseq) et les colonnes représentent les différents échantillons analysés.

- Les métadonnées décrivant les échantillons sous forme d'un _data frame_. Les lignes de ce tableau représentent les différents échantillons (l'ordre des lignes doit correspondre exactement à l'ordre des colonnes des données d'expression).

- Un _slot_ avec les **métadonnées décrivant les _features_** sous forme d'un _data frame_. également. Dans cette table, les lignes représentent chaque _feature_ et l'ordre de ces lignes doit être le même que dans la table des données d'expression.  Les colonnes de cette table représentent les co-variables des _features_ comme par exemple la localisation chromosomique des gènes, leur référence ENSEMBL ou leur fonction.

La structure coordonnée du `SummarizedExperiment` garantit que
lors de la manipulation des données, les dimensions des différents _slots_ corresponderont toujours
(c'est-à-dire les colonnes des données d'expression puis les lignes de
les exemples de métadonnées, ainsi que les lignes des données d'expression et les
métadonnées des fonctionnalités). Par exemple, si nous devions
exclure un échantillon du test, il serait automatiquement supprimé
des métadonnées de l’échantillon au cours de la même opération.

On peut par contre peut ajouter aux _slots_ de métadonnées des co-variables supplémentaires
(colonnes) sans affecter les autres structures.

### Création d'un SummarizedExperiment

Afin de créer un `SummarizedExperiment`, nous allons commencer par en créer les
composants individuels, c'est-à-dire la matrice de comptage, la table de métadonnées des échantillons et celle des _features_. Nous allons générer ces tables à partir de fichiers csv C'est généralement ainsi que les données RNA-Seq sont
fournies (après le traitement des données brutes).

```{r, echo=FALSE, message=FALSE}
rna <- read_csv("data/rnaseq.csv")

## count matrix
counts <- rna |>
  select(gene, sample, expression) |>
  pivot_wider(names_from = sample,
              values_from = expression)

## convert to matrix and set row names
count_matrix <- counts |>
  select(-gene) |>
  as.matrix()
rownames(count_matrix) <- counts$gene

## sample annotation
sample_metadata <- rna |>
  select(sample, organism, age, sex, infection, strain, time, tissue, mouse)

## remove redundancy
sample_metadata <- unique(sample_metadata)

## gene annotation
gene_metadata <- rna |>
  select(gene, ENTREZID, product, ensembl_gene_id, external_synonym,
         chromosome_name, gene_biotype, phenotype_description,
         hsapiens_homolog_associated_gene_name)

# remove redundancy
gene_metadata <- unique(gene_metadata)

## write to csv
write.csv(count_matrix, file = "data/count_matrix.csv")
write.csv(gene_metadata, file = "data/gene_metadata.csv", row.names = FALSE)
write.csv(sample_metadata, file = "data/sample_metadata.csv", row.names = FALSE)
```

- **Une matrice d'expression** : nous chargeons la matrice de comptage, en spécifiant que
  la première colonnes contient les noms des gènes, et nous convertissons le _data frame_ en une `matrice`. Vous pouvez télécharger le _data frame_
  [ici](https://carpentries-incubator.github.io/bioc-intro/data/count_matrix.csv).

```{r}
count_matrix <- read.csv("data/count_matrix.csv",
                         row.names = 1) %>%
    as.matrix()

count_matrix[1:5, ]
dim(count_matrix)
```

- **Un tableau décrivant les échantillons**, disponible
  [ici](https://carpentries-incubator.github.io/bioc-intro/data/sample_metadata.csv).

```{r}
sample_metadata <- read.csv("data/sample_metadata.csv")
sample_metadata
dim(sample_metadata)
```

- **Un tableau décrivant les gènes**, disponible
  [ici](https://carpentries-incubator.github.io/bioc-intro/data/gene_metadata.csv).

```{r}
gene_metadata <- read.csv("data/gene_metadata.csv")
gene_metadata[1:10, 1:4]
dim(gene_metadata)
```

Nous allons créer un `SummarizedExperiment` à partir de ces tables :

- La matrice de comptage sera utilisée comme _**assay**_

- Le tableau décrivant les échantillons sera utilisé comme emplacement de métadonnées \*\*sample
  \*\*

- Le tableau décrivant les gènes sera utilisé comme emplacement de métadonnées \*\*features
  \*\*

Nous allons assembler les différentes parties à l'aide du constructeur
`SummarizedExperiment` :

```{r, message=FALSE, warning=FALSE}
## BiocManager::install("SummarizedExperiment")
bibliothèque("SummarizedExperiment")
```

Tout d’abord, il est impératif de s'assurer que les échantillons sont dans le même ordre dans la matrice de comptage et dans les annotations des échantillons. De même, nous allons vérifier que l'ordre des gènes de la matrice de comptage correspond bien à l'ordre des gènes dans les métadonnées les décrivant.

```{r}
stopifnot(rownames(count_matrix) == gene_metadata$gene)
stopifnot(colnames(count_matrix) == sample_metadata$sample)
```

```{r}
se <- SummarizedExperiment(assays = list(counts = count_matrix),
                           colData = sample_metadata,
                           rowData = gene_metadata)
se
```

### La sauvegarde des données

L'export de données vers un tableur, comme nous l'avons fait dans un épisode précédent, présente
plusieurs limitations, comme celles décrites dans le premier chapitre
(éventuelles incohérences avec `,` et `.` pour les séparateurs décimaux et
manque de définitions de types de variables). De plus, l'exportation de données vers une feuille de calcul
n'est pertinente que pour les données rectangulaires telles que les _data frames_
et les matrices.

Une manière plus générale de sauvegarder des données, spécifique à R et dont le fonctionnement est
garanti sur n'importe quel système d'exploitation, consiste à utiliser la fonction `saveRDS()`
. Cette fonction sauvegardera une représentation binaire de l'objet sur le disque (en utilisant l'extension de fichier `.rds` ici), et celle-ci
pourra être rechargée dans R à l'aide de la fonction `readRDS`.

```{r, eval=FALSE}
saveRDS(se, file = "data_output/se.rds")
rm(se)
se <- readRDS("data_output/se.rds")
head(se)
```

Pour conclure, lorsqu'il s'agit de sauvegarder des données qui seront re-chargées
ultérieurement dans R, la sauvegarde et le chargement avec `saveRDS` et `readRDS` sont les approches
les plus adéquates. Si les données tabulaires doivent être partagées avec quelqu'un
qui n'utilise pas R, alors l'exportation vers une feuille de calcul sous forme de texte est une
bonne alternative.

En utilisant cette structure de données, nous pouvons accéder à la matrice d'expression avec
la fonction `assay()` :

```{r}
head(essai(se))
dim(essai(se))
```

Nous pouvons accéder aux de métadonnées des échantillons à l'aide de la fonction `colData` :

```{r}
colData(se)
dim(colData(se))
```

Nous pouvons également accéder aux métadonnées des _features_ à l'aide de la fonction `rowData()` :

```{r}
head(rowData(se))
dim(rowData(se))
```

### Sous-ensemble d'un SummarizedExperiment

Il est possible d'extraire un sous-ensemble d'un SummarizedExperiment exactement de la même manière que pour un _data frame_, en utilsant des indices ou des caractères logiques.

Ci-dessous, nous allons créer par exemple un nouveau SummarizedExperiment qui
ne contient que  les 5 premiers gènes et les 3 premiers échantillons.

```{r}
se1 <- se[1:5, 1:3]
se1
```

```{r}
colData(se1)
rowData(se1)
```

Nous pouvons également utiliser la fonction `colData()` pour créer un sous-ensemble basé sur une caractéristique des échantillons, ou la fonction `rowData()` pour créer un sous-ensemble basé sur une caractéristique des gènes.  Dans l'exemple ci-dessous, nous n'allons conserver que les gènes correspondant à des miRNAs et uniquement les échantillons non-infectés :

```{r}
se1 <- se[rowData(se)$gene_biotype == "miRNA",
          colData(se)$infection == "NonInfected"]
se1
assay(se1)
colData(se1)
rowData(se1)
```

<!--For the following exercise, you should download the SE.rda object
(that contains the `se` object), and open the file using the 'load()'
function.-->

<!-- ```{r, eval = FALSE, echo = FALSE} -->

<!-- download.file(url = "https://raw.githubusercontent.com/UCLouvain-CBIO/bioinfo-training-01-intro-r/master/data/SE.rda", -->

<!--               destfile = "data/SE.rda") -->

<!-- load("data/SE.rda") -->

<!-- ``` -->

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Extraire les niveaux d'expression génique des 3 premiers gènes dans les échantillons collectés
au temps 0 et au temps 8.

:::::::::::::::  solution

## Solution

```{r, purl=FALSE}
assay(se)[1:3, colData(se)$time != 4]

# Equivalent to
assay(se)[1:3, colData(se)$time == 0 | colData(se)$time == 8]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Vérifiez que vous obtenez les mêmes valeurs en utilisant la longue table `rna`.

:::::::::::::::  solution

## Solution

```{r, purl=FALSE}
arn |>
    filtre(gène %in% c("Asl", "Apod", "Cyd2d22")) |>
    filtre(temps != 4) |> select(expression )
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

La table en format long et le `SummarizedExperiment` contiennent les mêmes informations, mais sont simplement structurés différemment. Chaque structure a ses avantages propres: la première convient bien aux _packages_ `tidyverse`,
tandis que la seconde est une structure adéquate pour faciliter l'analyse et le traitement statistique de nombreuses données omiques. Le `SummarizedExperiment` est par exemple utilisé lors des analyses de RNA-seq avec le package `DESeq2`.

#### Ajouter des variables aux métadonnées

Comme mentionné ci-dessus, il est possible d'ajouter des informations aux métadonnées.
Supposons que vous souhaitiez ajouter le centre où les échantillons ont été collectés...

```{r}
colData(se)$center <- rep("Université de l'Illinois", nrow(colData(se)))
colData(se)
```

Cela illustre le fait que les _slots_ de métadonnées peuvent croître indéfiniment sans
affecter les autres structures !

### TidyRésuméExpérience

Vous vous demandez peut-être si pouvons-nous utiliser les commandes Tidyverse pour interagir avec les objets
`SummarizedExperiment` ? La réponse est oui, nous pouvons le faire grâce au package
`tidySummarizedExperiment`.

Rappelez-vous à quoi ressemble notre objet SummarizedExperiment :

```{r, message=FALSE}
se
```

Chargez `tidySummarizedExperiment` puis jetez à nouveau un œil à l'objet se
.

```{r, message=FALSE}
#BiocManager::install("tidySummarizedExperiment")
library("tidySummarizedExperiment")

se
```

Il s'agit toujours d'un objet `SummarizedExperiment`, il conserve donc sa structure spécifique, mais nous pouvons maintenant le voir comme un _tibble_. Notez la première ligne de
la sortie dit ceci, c'est une abstraction `SummarizedExperiment`\-`tibble`
. Nous pouvons également voir dans la deuxième ligne affichée le nombre
de gènes et d'échantillons.

Si nous voulons revenir à la vue standard `SummarizedExperiment`, nous
pouvons le faire.

```{r}
options("restore_SummarizedExperiment_show" = TRUE)
se
```

Mais ici, nous restons sur la vue tibble.

```{r}
options("restore_SummarizedExperiment_show" = FALSE)
se
```

Nous pouvons maintenant utiliser les commandes Tidyverse pour interagir avec l'objet
`SummarizedExperiment`.

Nous pouvons utiliser `filter` pour filtrer les lignes en utilisant une condition, par exemple pour afficher
toutes les lignes pour un échantillon.

```{r}
se %>% filtre(.sample == "GSM2545336")
```

Nous pouvons utiliser « select » pour spécifier les colonnes que nous voulons afficher.

```{r}
se %>% sélectionner (.sample)
```

Nous pouvons utiliser `mutate` pour ajouter des informations sur les métadonnées.

```{r}
se %>% muter(center = "Université de Heidelberg")
```

Nous pouvons également combiner des commandes avec le _pipe_ '%>%' de tidyverse . Pour l'exemple de
, nous pourrions combiner `group_by` et `summarise` pour obtenir le nombre total de
pour chaque échantillon.

```{r}
se %>%
    group_by(.sample) %>%
    summarise(total_counts=sum(counts))
```

Nous pouvons également utiliser l'objet `SummarizedExperiment` comme un _tibble_ classique
pour la visualisation.

Ici, nous traçons la distribution des comptes par échantillon.

```{r tidySE-plot}
se |>
    ggplot(aes(counts + 1, group=.sample, color=infection)) +
    geom_density() +
    scale_x_log10() +
    theme_bw()
```

Pour plus d'informations sur `TidySummarizedExperiment`, consultez le site Web du package
[ici](https://stemangiola.github.io/tidySummarizedExperiment/).

**A retenir**

- Le `SummarizedExperiment` est un moyen très efficace de stocker et
  de gérer les données omiques.

- Les `SummarizedExperiments`sont utilisés dans de nombreux _packages_ Bioconductor.

Si vous suivez la prochaine formation axée sur l'analyse de séquençage d'ARN,
vous apprendrez à utiliser le package Bioconductor `DESeq2` pour faire des
analyses d'expression différentielle.  Ce _package_ utilise un `SummarizedExperiment` pour traiter l'ensemble des données.

:::::::::::::::::::::::::::::::::::::::: keypoints

- Bioconductor est un projet qui fournit un cadre et des _packages_ pour faciliter l'analyse et l’interprétation des données issues de la biologie à haut débit.
- Un `SummarizedExperiment` est un type d'objet particulièrement utile pour stocker et traiter ce type de donnée.

::::::::::::::::::::::::::::::::::::::::::::::::::
