---
source: Rmd
title: Commencer par les données
teaching: 30
exercises: 30
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- Décrire ce qu'est un data frame.
- Charger des données externes à partir d'un fichier .csv dans un data frame.
- Résumer le contenu d'un data frame.
- Décrire ce qu'est un facteur.
- Convertissez entre les chaînes de caractère et les facteurs.
- Réorganiser et renommer les facteurs.
- Formatez les dates.
- Exporter et enregistrez les données.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Première analyse de données dans R.

::::::::::::::::::::::::::::::::::::::::::::::::

> Cet épisode est basé sur la leçon des Data Carpentries intitulée : _Analyse des données et Visualisation dans R pour les écologistes_.

## Présentation des données d'expression des gènes

Nous allons utiliser une partie des données publiées par Blackmore , _The
effect of upper-respiratory infection on transcriptomic changes in the
CNS_. Le but de l'étude était de déterminer l'effet d'une infection des voies respiratoires supérieures sur les modifications de la transcription de l'ARN se produisant dans le cervelet et la moelle épinière après l'infection. Des souris C57BL/6, âgées de huit semaines et appariées selon le genre, ont été inoculées avec une solution saline ou avec la grippe A par voie intranasale et les changements transcriptomiques dans les tissus du cervelet et de la moelle épinière
ont été évalués par RNA-seq aux jours 0 (non infectées), 4 et 8.

L'ensemble de données est stocké sous forme de fichier CSV (_comma-separated values_ ou valeurs séparées par des virgules).  Chaque ligne
contient des informations pour une seule mesure d'expression d'ARN. Les onze premières colonnes représentent :

| Colonne    | Description                                                                                                                                                                               |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| gene       | Le nom du gène qui a été mesuré.                                                                                                                                          |
| sample     | Le nom de l’échantillon dans lequel l’expression du gène a été mesurée.                                                                                                   |
| expression | La valeur de l'expression des gènes.                                                                                                                                      |
| organism   | L'organisme/l'espèce - ici toutes les données proviennent de souris.                                                                                                      |
| age        | L'âge de la souris (ici toutes les souris ont 8 semaines)                                                                                                              |
| sex        | Le sexe de la souris.                                                                                                                                                     |
| infection  | L'état d'infection de la souris, c'est-à-dire infectée par la grippe A ou non infectée.                                                                                   |
| strain     | La souche grippale A.                                                                                                                                                     |
| time       | La durée de l'infection (en jours).                                                                                                                    |
| tissue     | Le tissu utilisé pour l'expérience d'expression génique, c'est-à-dire le cervelet (cerebellum) ou la moelle épinière (spinal cord). |
| mouse      | L'identifiant unique de la souris.                                                                                                                                        |

Nous allons utiliser la fonction R `download.file()` pour télécharger le fichier CSV contenant les données d'expression génique. Nous utiliserons ensuite `read.csv()` pour charger en mémoire le contenu du fichier CSV en tant qu'objet de classe `data.frame`.  Dans la commande `download.file`, la première entrée
est une chaîne de caractères avec l'URL source. Cette URL télécharge un fichier CSV à partir d'un dépôt GitHub (GitHub repository). Le second argument : `destfile = "data/rnaseq.csv"` (texte après la virgule) correspond à la destination du fichier sur votre machine locale. Vous aurez besoin d'un dossier sur votre ordinateur appelé
`"data"` dans lequel vous téléchargerez le fichier. Pour récapituler, cette commande télécharge le fichier distant, le nomme `"rnaseq.csv"` et l'ajoute à un dossier
préexistant nommé `"data"`.

```{r, eval=TRUE}
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv" )
```

Vous êtes maintenant prêt à charger les données dans `R`:

```{r, eval=TRUE, purl=TRUE}
arn <- read.csv("data/rnaseq.csv")
```

Cette instruction ne produit aucune sortie dans la console car, comme vous vous en souvenez peut-être, les commandes d'assignation n'affichent rien. Si nous voulons vérifier que nos données ont bien été chargées, nous pouvons voir le contenu du data frame (tableau de données) en en tapant son nom :

```{r, eval=FALSE}
arn
```

Ouah... cela fait beaucoup de lignes de sorties. Cela signifie que les données ont été chargées correctement dans l'environnement de travail. Vérifions le haut (les 6 premières lignes) de ce data frame
en utilisant la fonction `head()` :

```{r, purl=TRUE}
head(rna)
## Essayez aussi
## View(rna)
```

**Note**

`read.csv()` suppose que les champs soient délimités par des virgules. Cependant, dans plusieurs pays et notamment en France, la virgule est utilisée comme séparateur décimal et le point-virgule (;) est utilisé comme délimiteur de champ. Si vous souhaitez lire ce type de fichiers dans R, vous pouvez utiliser la fonction `read.csv2()`. Il se comporte exactement comme `read.csv()` mais utilise des paramètres différents pour la décimale et les séparateurs de champ. Si vous travaillez avec un autre format de données
, ces paramètres peuvent tous deux être spécifiés explicitement par l'utilisateur. Consultez l'aide de la fonction `read.csv()` en tapant `?read.csv` pour en savoir plus. Il existe également la fonction
`read.delim()` pour lire des fichiers de données séparées par des tabulations. Il est important de
noter que toutes ces fonctions sont en fait des fonctions wrapper pour
la fonction principale `read.table()` avec différents arguments.  Par exemple, les données ci-dessus auraient également pu être chargées en utilisant `read.table()` avec l'argument de séparation (`sep`) égal à `","` selon le code suivant :

```{r, eval=TRUE, purl=TRUE}
rna <- read.table(file = "data/rnaseq.csv",
                  sep = ",",
                  header = TRUE)
```

L'argument `header` (en-tête) doit être défini comme étant `TRUE` pour pouvoir lire les en-têtes du fichier CSV, puisque par défaut dans `read.table()`, l'argument `header` défini comme étant `FALSE`.

## Qu'est-ce qu'un data frame ?

Le data frame (tableau de données) est une structure de données _de facto_ pour la plupart des données tabulaires et ce que nous utilisons pour calculer des statistiques et faire des graphiques.

Un data frame peut être créé à la main, mais le plus souvent celui-ci est
générés par les fonctions `read.csv()` ou `read.table()`, c'est-à-dire lors de l'importation de feuilles de calcul depuis votre disque dur (ou le web).

Le data frame représente les données sous la forme d'un tableau
où les colonnes sont des vecteurs qui ont tous la même longueur. Étant donné que les colonnes
sont des vecteurs (de classe `vector`), chaque colonne doit contenir un seul type de données
(par exemple, des caractères, des entiers, des facteurs). Par exemple, voici une figure
représentant un data frame comprenant trois vecteurs : un numérique, un  caractère et un logique.

![](./fig/data-frame.svg)

Nous pouvons le voir lors de l'inspection de la <b>str</b>ucture d'un data frame avec la fonction `str()` :

```{r}
str(arn)
```

## Inspection des objets `data.frame`

Nous avons déjà vu comment les fonctions `head()` et `str()` peuvent être utiles pour vérifier le contenu et la structure d'un data frame. Voici une
liste non exhaustive de fonctions pour avoir une idée du
contenu ou de la structure des données. Essayons-les !

**Dimension** :

- `dim(rna)` - renvoie un vecteur avec le nombre de lignes comme premier élément
  et le nombre de colonnes comme deuxième élément (les
  **dim**ensions de l'objet).
- `nrow(rna)` - renvoie le nombre de lignes.
- `ncol(rna)` - renvoie le nombre de colonnes.

**Contenu** :

- `head(rna)` - affiche les 6 premières lignes.
- `tail(rna)` - affiche les 6 dernières lignes.

**Noms** :

- `names(rna)` - renvoie les noms de colonnes (synonyme de `colnames()` pour les objets
  `data.frame`).
- `rownames(rna)` - renvoie les noms de lignes.

**Résumé** :

- `str(rna)` - structure de l'objet et informations sur la classe
  , longueur et contenu de chaque colonne.
- `summary(rna)` - statistiques récapitulatives pour chaque colonne.

Remarque : la plupart de ces fonctions sont "génériques", c'est-à-dire qu'elles peuvent être utilisées sur d'autres types d'objets
en plus des objets `data.frame`.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Sur la base du résultat de `str(rna)`, pouvez-vous répondre aux
questions suivantes ?

- Quelle est la classe de l’objet `rna` ?
- Combien de lignes et combien de colonnes y a-t-il dans cet objet ?

::::::::::::::: solution

## Solution

- classe : data frame
- Nombre de lignes : 66465, Nombre de colonnes : 11

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

## Indexation et création de sous-ensembles de data frames

Notre data frame « rna » comporte des lignes et des colonnes (il a 2 dimensions) ; si nous
voulons en extraire des données spécifiques, nous devons spécifier les
"coordonnées" que nous voulons. Les numéros de ligne viennent en premier, suivis des numéros de colonne. Cependant, notez qu'il y a différentes manières de spécifier ces coordonnées,
conduisant à des résultats avec des classes différentes.

```{r, eval=FALSE, purl=TRUE}
# premier élément de la première colonne du bloc de données (sous forme de vecteur)
rna[1, 1]
# premier élément de la 6ème colonne (sous forme de vecteur)
rna [1, 6]
# première colonne du bloc de données (sous forme de vecteur)
rna[, 1]
# première colonne du bloc de données (sous forme de data.frame )
rna[1]
# les trois premiers éléments de la 7ème colonne (en tant que vecteur)
rna[1:3, 7]
# la 3ème ligne de la trame de données (en tant que data.frame)
rna[3, ]
# équivalent à head_rna <- head(rna)
head_rna <- rna[1:6, ]
head_rna
```

`:` est une fonction spéciale qui crée des vecteurs numériques d'entiers dans un
ordre croissant ou décroissant. Testez `1:10` et `10:1` par exemple. Voir section @ref(sec:genvec) pour plus de détails.

Vous pouvez également exclure certains indices d'un data frame à l'aide du signe "`-`" :

```{r, eval=FALSE, purl=TRUE}
rna[, -1] ## La trame de données entière, sauf la première colonne
rna[-c(7:66465), ] ## Équivalent à head(rna)
```

L'on peut créer des sous-ensembles à partir des data frames en utilisant des indices (comme vu précédemment),
mais aussi en appelant directement les noms de colonnes à extraire :

```{r, eval=FALSE, purl=TRUE}
rna["gene"]       # Result is a data.frame
rna[, "gene"]     # Result is a vector
rna[["gene"]]     # Result is a vector
rna$gene          # Result is a vector
```

Dans RStudio, vous pouvez utiliser la fonctionnalité de saisie automatique pour obtenir les noms complets et
corrects des colonnes.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

1. Créez un `data.frame` (`rna_200`) contenant uniquement les données de la ligne 200 du jeu de données `rna`.

2. Notez comment `nrow()` vous a donné le nombre de lignes dans un `data.frame` ?

- Utilisez ce chiffre pour extraire uniquement la dernière ligne du data frame initial
  `rna`.

- Comparez ceci avec la dernière ligne du data frame en utilisant `tail()` pour s'assurer d'obtenir des résultats identiques.

- Extrayez à présent cette dernière ligne en utilisant `nrow()` au lieu du numéro de ligne.

- Créez un nouveau data frame (`rna_last`) à partir de cette dernière ligne.

3. Utilisez `nrow()` pour extraire la ligne qui se trouve au milieu du data frame
  `rna`. Stockez le contenu de cette ligne dans un objet
  nommé `rna_middle`.

4. Combinez `nrow()` avec la notation `-` ci-dessus pour reproduire le comportement
  de `head(rna)`, en conservant uniquement les lignes 1 à 6 du data frame `rna`.

::::::::::::::: solution

## Solution

```{r, purl=TRUE}
## 1.
rna_200 <- rna[200, ]
## 2.
## Sauvegarde de `n_rows` pour améliorer la lisibilité et réduire la duplication
n_rows < - nrow(rna)
rna_last <- rna[n_rows, ]
## 3.
rna_middle <- rna[n_rows / 2, ]
## 4 .
rna_head <- rna[-(7:n_rows), ]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

## Facteurs

Les facteurs représentent des **données catégorielles**. Ils sont stockés sous forme d'entiers (integer) avec des étiquettes associées et ils peuvent être ordonnés ou non. Alors que les facteurs
ressemblent (et se comportent souvent) comme des vecteurs de caractères, ils sont
en réalité traités comme des vecteurs entiers par R. Vous devez donc être très
prudent lorsque vous les traitez comme des chaînes.

Une fois créés, les facteurs ne peuvent contenir qu'un ensemble prédéfini de valeurs ou _niveaux_. Par défaut, R trie toujours les niveaux par ordre alphabétique. Par exemple, si vous avez un facteur à 2 niveaux :

```{r, purl=TRUE}
sexe <- factor(c("mâle", "femelle", "femelle", "mâle", "femelle"))
```

R va assigner `1` au niveau `"female"` et `2` au niveau
`"male"` (puisque `f` vient avant `m`, même si le premier élément
de ce vecteur est `"male"`). Vous pouvez le vérifier en utilisant la fonction
`levels()` et vous pouvez trouver le nombre de niveaux en utilisant `nlevels()` :

```{r, purl=TRUE}
niveaux(sexe)
nniveaux(sexe)
```

Parfois, l'ordre des facteurs n'a pas d'importance, d'autres fois vous
pourriez vouloir spécifier l'ordre car il est pertinent (par exemple, "faible",
"moyen", "élevé"), il améliore votre visualisation, ou il est requis
par un type particulier d'analyse. Ici, une façon de réorganiser nos niveaux
dans le vecteur `sex` serait :

```{r, purl=TRUE}
sex ## commande actuelle
sex <- factor(sex,levels = c("male", "female"))
sex ## après la nouvelle commande
```

Ces facteurs sont représentés par des entiers (ex: 1, 2, 3) dans la mémoire de R
mais ils sont plus informatifs que les entiers car les facteurs se décrivent d'eux-mêmes
: `"female"`, `"male" ` est plus descriptif que `1`,
`2`. Lequel est « male » ?  Vous ne seriez pas en mesure de le savoir uniquement à partir des données entières
. Les facteurs, en revanche, intègrent cette information.
Ceci est particulièrement utile lorsqu'il existe de nombreux niveaux (comme le biotype du gène
dans notre exemple d'ensemble de données).

Lorsque vos données sont stockées sous forme de facteur, vous pouvez utiliser la fonction `plot()` pour obtenir un aperçu rapide du nombre d'observations
représenté par chaque niveau de facteur. Regardons le nombre d'hommes
et de femmes dans nos données.

```{r firstfactorplot, fig.cap="Bar plot of the number of females and males.", purl=TRUE}
intrigue (sexe)
```

### Conversion en chaîne de caractères

Un facteur peut être converti en vecteur caractère, vous pouvez utiliser la fonction
`as.character(x)`.

```{r, purl=TRUE}
as.personnage (sexe)
```

<!-- ### Numeric factors -->

<!-- Converting factors where the levels appear as numbers (such as -->

<!-- concentration levels, or years) to a numeric vector is a little -->

<!-- trickier. The `as.numeric()` function returns the index values of the -->

<!-- factor, not its levels, so it will result in an entirely new (and -->

<!-- unwanted in this case) set of numbers.  One method to avoid this is to -->

<!-- convert factors to characters, and then to numbers.  Another method is -->

<!-- to use the `levels()` function. Compare: -->

<!-- ```{r} -->

<!-- year_fct <- factor(c(1990, 1983, 1977, 1998, 1990)) -->

<!-- as.numeric(year_fct)  ## Wrong! And there is no warning... -->

<!-- as.numeric(as.character(year_fct)) ## Works... -->

<!-- as.numeric(levels(year_fct))[year_fct] ## The recommended way. -->

<!-- ```

<!-- Notice that in the `levels()` approach, three important steps occur: -->

<!-- * We obtain all the factor levels using `levels(year_fct)` -->

<!-- * We convert these levels to numeric values using `as.numeric(levels(year_fct))` -->

<!-- * We then access these numeric values using the underlying integers of the -->

<!--   vector `year_fct` inside the square brackets -->

### Renommer les facteurs

Si l'on veut renommer ces facteurs, il suffit de changer ses niveaux avec la fonction `levels()`
:

```{r, purl=TRUE}
niveaux(sexe)
niveaux(sexe) <- c("M", "F")
sexe
intrigue(sexe)
```

:::::::::::::::::::::::::::::::::::::: défi

## Défi

- Renommez `F` et `M` respectivement en `Female` et `Male`.

::::::::::::::: solution

## Solution

```{r, eval=TRUE, purl=TRUE}
niveaux(sexe)
niveaux(sexe) <- c("Homme", "Femme")
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Nous avons vu comment les data frame sont créés avec `read.csv()`, mais
ils peuvent également être créés à la main avec la fonction `data.frame()`.
Il y a quelques erreurs dans ce `data.frame` construit manuellement. Pouvez-vous
les repérer et les corriger ?  N'hésitez pas à expérimenter !

```{r, eval=FALSE}
animal_data <- data.frame(
       animal = c(dog, cat, sea cucumber, sea urchin),
       feel = c("furry", "squishy", "spiny"),
       weight = c(45, 8 1.1, 0.8))
```

::::::::::::::: solution

## Solution

- Les guillemets sont manquants autour des noms des animaux.
- Il manque une entrée dans la colonne `feel` (probablement pour l'un des animaux à fourrure).
- Il manque une virgule dans la colonne `weight`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Pouvez-vous prédire la classe de chacune des colonnes dans l'exemple
suivant ?

Vérifiez vos suppositions en utilisant `str(country_climate)` :

- Sont-ils ce à quoi vous vous attendiez ?  Pourquoi? Pourquoi pas?

- Réessayez en ajoutant `stringsAsFactors = TRUE` après la dernière variable
  lors de la création du data frame. Que se passe-t-il à présent ?
  `stringsAsFactors` peut également être défini lors de la lecture de feuilles de calcul
  basées sur du texte dans R à l'aide de `read.csv()`.

```{r, eval=FALSE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "Afrique du Sud", "Australie"),
       climat = c("froid", "chaud" , "tempéré", "chaud/tempéré"),
       température = c(10, 30, 18, "15"),
       hémisphère_nord = c(VRAI, VRAI, FAUX, "FAUX" ),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
)
```

::::::::::::::: solution

## Solution

```{r, eval=TRUE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "Afrique du Sud", "Australie"),
       climat = c("froid", "chaud" , "tempéré", "chaud/tempéré"),
       température = c(10, 30, 18, "15"),
       hémisphère_nord = c(VRAI, VRAI, FAUX, "FAUX" ),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
       )
str(country_climate)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

La conversion automatique du type de données est parfois une bénédiction, parfois un
désagrément. Sachez que cela existe, apprenez les règles et vérifiez que les données
que vous importez dans R sont du bon type dans votre data frame. Sinon, utilisez-le
à votre avantage pour détecter les erreurs qui auraient pu être introduites lors de la saisie des données
(une lettre dans une colonne qui ne doit contenir que des chiffres par exemple).

Apprenez-en plus dans ce tutoriel RStudio


## Matrices

Avant de continuer, maintenant que nous avons découvert les data frames,
récapitulons l'installation de packages et découvrons un nouveau type de données, à savoir la classe `matrix`. Comme un objet de classe `data.frame`, une matrice a deux dimensions, des lignes et
colonnes. La différence majeure est que toutes les cellules d'une matrice doivent
être du même type : « numérique », « caractère », « logique », ... À cet égard, les matrices sont plus proches d'un vecteur que d'un data frame.

Le constructeur par défaut d'une matrice est « matrix ». Le remplissage de la matrice nécessite un vecteur de
valeurs et de fixer le nombre de lignes et/ou
colonnes\[^`ncol`]. Les valeurs sont triées le long des colonnes, comme illustré
ci-dessous.

```{r mat1, purl=TRUE}
m <- matrice (1:9, ncol = 3, nrow = 3)
m
```

[^ncol]: Définir uniquement le nombre de lignes ou de colonnes est suffisant, l'autre dimension pouvant être déduite de la valeur fournie. Essayez de voir ce qu'il se passe si le produit entre le nombre de lignes/colonnes et le nombre de valeurs ne correspondent pas.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

À l'aide de la fonction `installed.packages()`, créez une matrice caractère
contenant les informations sur tous les packages actuellement installés sur
votre ordinateur. Explorez-la.

::::::::::::::: solution

## Solution

```{r pkg_sln, eval=FALSE, purl=TRUE}
## créer la matrice
ip <- Installed.packages()
head(ip)
## essayez aussi View(ip)
## numéro de paquet
nrow(ip)
## noms de tous les packages installés
rownames(ip)
## type d'informations dont nous disposons sur chaque package
noms de colonnes (ip)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

Il est souvent utile de créer de grandes matrices de données aléatoires comme données de test. L'exercice ci-dessous vous demande de créer une telle matrice avec des données aléatoires
tirées d'une distribution normale de moyenne 0 et d'écart type
1, ce qui peut être fait avec la fonction `rnorm()`.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Construire une matrice de dimension 1000 (nombre de lignes) par 3 (nombre de colonnes) de données normalement distribuées
(moyenne 0, écart type 1).

::::::::::::::: solution

## Solution

```{r rnormmat_sln, purl=TRUE}
set.seed(123)
m <- matrice(rnorm(3000), ncol = 3)
dim(m)
tête(m)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

## Formatage des dates

L'un des problèmes les plus courants rencontrés par les nouveaux (et les plus expérimentés !)  utilisateurs de R concerne
la conversion des informations de date et d'heure en une variable
appropriée et utilisable lors des analyses.

### Remarque sur les dates dans les tableurs

Les dates dans les feuilles de calcul sont généralement stockées dans une seule colonne. Bien que
cela semble la manière la plus naturelle d'enregistrer des dates, ce ne fait en réalité pas partie des bonnes pratiques. Un tableur affichera les dates d'une manière
apparemment correcte (pour un observateur humain), mais la façon dont il
gère et stocke réellement les dates peut être problématique. Il est souvent
plus sûr de stocker les dates avec ANNÉE, MOIS et JOUR dans des colonnes séparées ou
comme ANNÉE et JOUR DE L'ANNÉE dans des colonnes séparées.

Des tableurs tels que LibreOffice, Microsoft Excel, OpenOffice,
Gnumeric, ... ont des manières différentes (et souvent incompatibles) d'encoder les dates
(même pour le même programme entre les versions et les systèmes d'exploitation). De plus, Excel peut [transformer des éléments qui ne sont pas des dates en dates
](https://nsaunders.wordpress.com/2012/10/22/gene-name-errors-and-excel-lessons-not -learned/)
(@Zeeberg:2004), par exemple des noms ou des identifiants comme MAR1, DEC1,
OCT4. Donc, si vous évitez de façon générale le format date, il est plus facile d'identifier ces problèmes.

La section Dates as
data
de la leçon Data Carpentry fournit des informations supplémentaires
sur les pièges des dates avec des feuilles de calcul.

Nous allons utiliser la fonction `ymd()` du package
**`lubridate`** (qui appartient au **`tidyverse`** ; en savoir plus
[ici] (https://www.tidyverse.org/)). . **`lubridate`** est automatiquement installé lors de l'installation de **`tidyverse`**. Lorsque vous chargez le
**`tidyverse`** (commande `library(tidyverse)`), les packages de base (les packages
utilisés dans la plupart des analyses de données) sont chargés. **`lubridate`**
n'appartient cependant pas aux fonctionnalités de base de tidyverse, vous devez donc le charger
explicitement avec `library(lubridate)`.

Commencez par charger le package requis :

```{r loadlibridate, message=FALSE, purl=TRUE}
bibliothèque("lubrifier")
```

`ymd()` prend un vecteur représentant l'année, le mois et le jour, et le convertit
en un vecteur `Date`. `Date` est une classe de données reconnue par R comme
étant une date et peut être manipulée comme telle. L'argument requis par la fonction
est flexible, mais, à titre de bonnes pratiques, il s'agit d'un vecteur de caractère
au format "AAAA-MM-JJ".

Créons un objet date et inspectons la structure :

```{r, purl=TRUE}
ma_date <- ymd("2015-01-01")
str(ma_date)
```

Collons maintenant l'année, le mois et le jour séparément - nous obtenons le même résultat :

```{r, purl=TRUE}
# sep indique le caractère à utiliser pour séparer chaque composant
my_date <- ymd(paste("2015", "1", "1", sep = "-"))
str(my_date )
```

Familiarisons-nous maintenant avec un pipeline typique de manipulation de date
. Le data frame ci-dessous a stocké des dates dans différentes colonnes « year »,
« month » et « jour ».

```{r, purl=TRUE}
x <- data.frame(année = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),
                mois = c(2, 3, 3, 10, 1 , 8, 3, 4, 5, 5),
                jour = c(24, 8, 1, 5, 8, 17, 13, 10, 11, 24),
                valeur = c (4, 5, 1, 9, 3, 8, 10, 2, 6, 7))
x
```

Nous appliquons maintenant cette fonction à l'ensemble du jeu de données « x ». Nous créons d'abord un vecteur de caractères
à partir des colonnes `year`, `month` et `day` de `x`
en utilisant `paste()` :

```{r, purl=TRUE}
coller(x$year, x$month, x$day, sep = "-")
```

Ce vecteur de caractères peut être utilisé comme argument pour `ymd()` :

```{r, purl=TRUE}
ymd(coller(x$year, x$month, x$day, sep = "-"))
```

Le vecteur `Date` résultant peut être ajouté à `x` en tant que nouvelle colonne appelée `date` :

```{r, purl=TRUE}
x$date <- ymd(paste(x$year, x$month, x$day, sep = "-"))
str(x) # remarquez la nouvelle colonne, avec 'date' comme classe
```

Assurons-nous que tout a fonctionné correctement. Une façon d'inspecter la nouvelle colonne
est d'utiliser la fonction `summary()` :

```{r, purl=TRUE}
résumé(x$date)
```

Notez que `ymd()` s'attend à avoir successivement l'année, le mois et le jour. Si vous avez par exemple le jour, le mois et l'année, vous aurez besoin de la fonction
`dmy()`.

```{r, purl=TRUE}
dmy(coller(x$day, x$month, x$year, sep = "-"))
```

`lubdridate` a de nombreuses fonctions pour gérer toutes les variantes de date.

## Résumé des objets R

Jusqu'à présent, nous avons vu plusieurs types d'objets R variant selon le nombre
de dimensions et s'ils pouvaient stocker un ou plusieurs types de données
 :

- **`vector`** : une dimension (ils ont une longueur), un seul type de données.
- **`matrix`** : deux dimensions, un seul type de données.
- **`data.frame`** : deux dimensions, un type par colonne.

## Listes

Un type de données que nous n'avons pas encore vu, mais qu'il est utile de connaître, et
découle du résumé que nous venons de voir sont des listes (classe `list`) :

- **`list`** : une dimension, chaque élément peut être d'un type de données différent
  .

Ci-dessous, créons une liste contenant un vecteur de nombres, de caractères,
une matrice, un data frame et une autre liste :

```{r list0, purl=TRUE}
l <- list(1:10, ## numérique
          lettres, ## caractère
          installé.packages(), ## une matrice
          voitures, ## un data.frame
          liste(1, 2, 3)) ## une liste
longueur(l)
str(l)
```

L'indiçage (i.e. la réalisation d'un sous-ensemble) de liste est effectué en utilisant `[]` pour créer une nouvelle sous-liste ou `[[]]`
pour extraire un seul élément de cette liste (en utilisant des indices ou des noms si
la liste possède un attribut de nom).

```{r, purl=TRUE}
l[[1]] ## premier élément
l[1:2] ## une liste de longueur 2
l[1] ## une liste de longueur 1
```

## Exportation et sauvegarde de données tabulaires {#sec:exportandsave}

Nous avons vu comment lire une feuille de calcul textuelle dans R à l'aide de la famille de fonctions
`read.table`. Pour exporter un `data.frame` vers une feuille de calcul texte
, nous pouvons utiliser l'ensemble de fonctions `write.table` (`write.csv`, `write.delim`, ...). Ils ont tous pour arguments la variable à
exporter et le fichier vers lequel exporter. Par exemple, pour exporter les données
`rna` vers le fichier `my_rna.csv` dans le répertoire `data_output`, nous exécuterions :

```{r writecsv, eval=FALSE, purl=TRUE}
write.csv(rna, file = "data_output/my_rna.csv")
```

Ce nouveau fichier csv peut maintenant être partagé avec d'autres collaborateurs qui ne sont pas familiers avec R. Notez que même s'il y a des virgules dans certains des champs dans le `data.frame` (voir par exemple la colonne "product"), R entourera par défaut chaque champ de texte avec des guillemets. Nous serons donc en mesure de
le lire à nouveau dans R correctement, malgré l'utilisation de virgules comme séparateurs de colonnes.

:::::::::::::::::::::::::::::::::::::::: keypoints

- Données tabulaires dans R

::::::::::::::::::::::::::::::::::::::::::::::::
