---
source: Rmd
title: Introduction to R
teaching: 60
exercises: 60
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- Defina os seguintes termos relacionados com o R: objeto, atribuição, chamada, função, argumentos, opções.
- Atribua valores a objectos em R.
- Aprenda a dar _nome_ aos objectos
- Utilize os comentários para informar o guião.
- Resolva operações aritméticas simples em R.
- Chame funções e utilize argumentos para alterar as suas opções predefinidas.
- Inspeccione o conteúdo dos vectores e manipule o seu conteúdo.
- Subconjunto e extrair valores de vectores.
- Analise vectores com dados em falta.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Primeiros comandos em R

::::::::::::::::::::::::::::::::::::::::::::::::::

> Este episódio baseia-se na lição _Data Analysis and
> Visualisation in R for Ecologists_ do Data Carpentries.

## Criar objectos no R

Pode obter resultados do R simplesmente escrevendo math na consola:

```{r, purl=TRUE}
3 + 5
12 / 7
```

No entanto, para fazer coisas úteis e interessantes, precisamos de atribuir _valores_ a
_objectos_. Para criar um objeto, temos de lhe dar um nome seguido do operador de atribuição
`<-`, e o valor que lhe queremos dar:

```{r, purl=TRUE}
weight_kg <- 55
```

`<-` é o operador de atribuição. Atribui valores à direita a
objectos à esquerda. Assim, após executar `x <- 3`, o valor de `x` é
`3`. A seta pode ser lida como 3 **entra em** `x`.  Por razões históricas
, pode também utilizar `=` para atribuições, mas não em todos os contextos
. Devido às
[ligeiras diferenças](https://blog.revolutionanalytics.com/2008/12/use-equals-or-arrow-for-assignment.html)
na sintaxe, é boa prática utilizar sempre `<-` para atribuições.

No RStudio, digitar <kbd>Alt</kbd> + <kbd>\-</kbd> (pressione <kbd>Alt</kbd>
ao mesmo tempo que a tecla <kbd>\-</kbd> ) escreverá `<-` em um único pressionamento de tecla
em um PC, enquanto digitar <kbd>Option</kbd> + <kbd>\-</kbd> (pressione <kbd>Option</kbd> ao mesmo tempo que a tecla <kbd>\-</kbd> ) faz o
mesmo em um Mac.

### Nomear variáveis

Os objectos podem receber qualquer nome, como `x`, `temperatura_actual`, ou
`id_assunto`. Pretende que os nomes dos seus objectos sejam explícitos e não muito
longos. Não podem começar por um número (`2x` não é válido, mas `x2`
é). R é sensível a maiúsculas e minúsculas (por exemplo, `weight_kg` é diferente de
`Weight_kg`). Existem alguns nomes que não podem ser utilizados porque
são nomes de funções fundamentais em R (por exemplo, `if`, `else`,
`for`, veja
[aqui](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html)
para uma lista completa). Em geral, mesmo que seja permitido, é melhor
não utilizar outros nomes de funções (por exemplo, `c`, `T`, `mean`, `data`, `df`,
`weights`). Em caso de dúvida, consulte a ajuda para ver se o nome já está
a ser utilizado. Também é melhor evitar pontos (`.`) dentro de um nome de objeto como em
`my.dataset`. Existem muitas funções no R com pontos nos seus nomes
por razões históricas, mas como os pontos têm um significado especial no R
(para métodos) e noutras linguagens de programação, é melhor evitar
os pontos. Recomenda-se também que utilize substantivos para nomes de objectos e verbos
para nomes de funções. É importante ser consistente no estilo do
seu código (onde coloca os espaços, como nomeia os objectos, etc.). A utilização de um estilo de codificação consistente
torna o seu código mais fácil de ler para o seu
futuro eu e para os seus colaboradores. Em R, alguns guias de estilo populares
são o [Google's](https://google.github.io/styleguide/Rguide.xml), o estilo
[tidyverse's](https://style.tidyverse.org/) e o Bioconductor
style
guide. O
tidyverse's é muito abrangente e pode parecer-lhe avassalador no
início. Pode instalar o pacote
[**`lintr`**](https://github.com/jimhester/lintr) para
verificar automaticamente se existem problemas no estilo do seu código.

> **Objectos vs. variáveis**: O que é conhecido como `objectos` no `R` é
> conhecido como `variáveis` em muitas outras linguagens de programação. Dependendo
> do contexto, `objeto` e `variável` podem ter significados drasticamente
> diferentes. No entanto, nesta lição, as duas palavras são utilizadas
> como sinónimos. Para mais informações, consulte
> [ver aqui].(https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects)

Quando atribui um valor a um objeto, o R não imprime nada. Você
pode forçar o R a imprimir o valor utilizando parênteses ou digitando o nome do objeto
:

```{r, purl=TRUE}
weight_kg <- 55    # doesn't print anything
(weight_kg <- 55)  # but putting parenthesis around the call prints the value of `weight_kg`
weight_kg          # and so does typing the name of the object
```

Agora que o R tem `peso_kg` na memória, podemos fazer aritmética com ele. Para
exemplo, pode querer converter este peso em libras (o peso em libras é 2,2 vezes o peso em kg):

```{r, purl=TRUE}
2.2 * weight_kg
```

Também podemos alterar o valor de um objeto atribuindo-lhe um novo valor:

```{r, purl=TRUE}
weight_kg <- 57.5
2.2 * weight_kg
```

Isto significa que atribuir um valor a um objeto não altera os valores de
outros objectos Por exemplo, vamos armazenar o peso do animal em libras num novo objeto
, `weight_lb`:

```{r, purl=TRUE}
weight_lb <- 2.2 * weight_kg
```

e, em seguida, altere `peso_kg` para 100.

```{r}
weight_kg <- 100
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Qual acha que é o conteúdo atual do objeto `weight_lb`?
126\.5 ou 220?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Comentários

O caractere de comentário no R é `#`, qualquer coisa à direita de um `#` num script
será ignorado pelo R. É útil deixar notas, e
explicações nos seus scripts.

O RStudio torna fácil comentar ou descomentar um parágrafo: depois de
selecionar as linhas que pretende comentar, prima ao mesmo tempo no
seu teclado <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>. Se
só quiser comentar uma linha, pode colocar o cursor em qualquer
local dessa linha (ou seja, não é necessário selecionar toda a linha), depois
prima <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>.

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio

Quais são os valores a seguir a cada afirmação no seguinte?

```{r, purl=TRUE}
mass <- 47.5            # mass?
age  <- 122             # age?
mass <- mass * 2.0      # mass?
age  <- age - 20        # age?
mass_index <- mass/age  # mass_index?
```

::::::::::::::::::::::::::::::::::::::::::::::::::

## Funções e seus argumentos

As funções são "scripts enlatados" que automatizam conjuntos de comandos mais complicados
incluindo atribuições de operações, etc. Muitas funções estão predefinidas, ou podem ser
disponibilizadas através da importação de _pacotes_ do R (mais sobre isso mais tarde). Uma função
recebe normalmente um ou mais inputs chamados _argumentos_. As funções devolvem frequentemente (mas não
sempre) um _valor_. Um exemplo típico é a função `sqrt()`. A entrada
(o argumento) tem de ser um número, e o valor de retorno (de facto, a saída
) é a raiz quadrada desse número. A execução de uma função ('running it')
chama-se _calling_ a função. Um exemplo de uma chamada de função é:

```{r, eval=FALSE, purl=FALSE}
b <- sqrt(a)
```

Aqui, o valor de `a` é dado à função `sqrt()`, a função `sqrt()`
calcula a raiz quadrada, e retorna o valor que é então atribuído a
o objeto `b`. Esta função é muito simples, porque recebe apenas um argumento.

O 'valor' de retorno de uma função não precisa de ser numérico (como o de `sqrt()`),
e também não precisa de ser um único item: pode ser um conjunto de coisas, ou
mesmo um conjunto de dados. Veremos isso quando lermos ficheiros de dados no R.

Os argumentos podem ser qualquer coisa, não apenas números ou nomes de ficheiros, mas também outros objectos
. O significado exato de cada argumento varia de acordo com a função e deve ser
consultado na documentação (ver abaixo). Algumas funções aceitam argumentos que
podem ser especificados pelo utilizador ou, se não forem especificados, assumem um valor _default_:
estas são chamadas _opções_. As opções são normalmente utilizadas para alterar a forma como a função
funciona, como por exemplo, se ignora 'valores maus', ou que símbolo
utilizar num gráfico.  No entanto, se pretender algo específico, pode especificar um valor
à sua escolha que será utilizado em vez do valor predefinido.

Vamos experimentar uma função que pode receber vários argumentos: `round()`.

```{r, results="show", purl=TRUE}
round(3.14159)
```

Aqui, nós chamamos `round()` com apenas um argumento, `3.14159`, e ele
retornou o valor `3`.  Isto porque a predefinição é arredondar para o número inteiro
mais próximo. Se quisermos mais dígitos, podemos ver como o fazer obtendo
informação sobre a função `round`.  Pode utilizar `args(round)` ou consultar a ajuda
para esta função utilizando `?round`.

```{r, results="show", purl=TRUE}
args(round)
```

```{r, eval=FALSE, purl=TRUE}
?round
```

Vemos que se quisermos um número diferente de dígitos, podemos
digitar `digits=2` ou o número que quisermos.

```{r, results="show", purl=TRUE}
round(3.14159, digits = 2)
```

Se fornecer os argumentos exatamente na mesma ordem em que são definidos, não precisa de lhes dar um nome
:

```{r, results="show", purl=TRUE}
round(3.14159, 2)
```

E se nomear os argumentos, pode mudar a sua ordem:

```{r, results="show", purl=TRUE}
round(digits = 2, x = 3.14159)
```

É uma boa prática colocar os argumentos não opcionais (como o número que está a
arredondar) em primeiro lugar na sua chamada de função e especificar os nomes de todos os argumentos opcionais
.  Se não o fizer, alguém que leia o seu código poderá ter de procurar a definição
de uma função com argumentos desconhecidos para perceber o que está
a fazer. Ao especificar o nome dos argumentos, está também a proteger
contra possíveis alterações futuras na interface da função, que podem
potencialmente adicionar novos argumentos entre os existentes.

## Vectores e tipos de dados

Um vetor é o tipo de dados mais comum e básico do R e é praticamente
o cavalo de batalha do R. Um vetor é composto por uma série de valores, tais como
números ou caracteres. Podemos atribuir uma série de valores a um vetor utilizando
a função `c()`. Por exemplo, podemos criar um vetor de pesos de animais e atribuí-lo
a um novo objeto `peso_g`:

```{r, purl=TRUE}
weight_g <- c(50, 60, 65, 82)
weight_g
```

Um vetor também pode conter caracteres:

```{r, purl=TRUE}
molecules <- c("dna", "rna", "protein")
molecules
```

As aspas em torno de "dna", "rna", etc. são essenciais aqui. Sem as aspas
o R assumirá que existem objectos chamados `dna`, `rna` e
`protein`. Como estes objectos não existem na memória do R, receberá
uma mensagem de erro.

Existem muitas funções que lhe permitem inspecionar o conteúdo de um vetor
. `length()` diz-lhe quantos elementos existem num determinado vetor:

```{r, purl=TRUE}
length(weight_g)
length(molecules)
```

Uma caraterística importante de um vetor é que todos os elementos são do
mesmo tipo de dados.  A função `class()` indica a classe (o
tipo de elemento) de um objeto:

```{r, purl=TRUE}
class(weight_g)
class(molecules)
```

A função `str()` fornece uma visão geral da estrutura de um objeto
e dos seus elementos. É uma função útil quando trabalha com
objectos grandes e complexos:

```{r, purl=TRUE}
str(weight_g)
str(molecules)
```

Pode utilizar a função `c()` para adicionar outros elementos ao seu vetor:

```{r}
weight_g <- c(weight_g, 90) # adiciona ao fim do vetor
weight_g <- c(30, weight_g) # adiciona ao início do vetor
weight_g
```

Na primeira linha, pegamos o vetor original `peso_g`, adicionamos o valor
`90` ao final dele, e salvamos o resultado de volta em
`peso_g`. De seguida, adicionamos o valor `30` ao início, guardando novamente
o resultado de volta em `peso_g`.

Podemos fazer isto repetidamente para fazer crescer um vetor, ou montar um conjunto de dados
.  À medida que programamos, isto pode ser útil para adicionar resultados que estamos
a recolher ou a calcular.

Um **vetor atómico** é o **tipo de dados** mais simples do R e é um
vetor linear de um único tipo. Acima, vimos 2 dos 6 principais tipos de vectores \*\*atómicos
\*\* que o R utiliza: `"character"` e `"numeric"` (ou
`"double"`). Estes são os blocos de construção básicos a partir dos quais todos os objectos R
são construídos. Os outros 4 tipos de vectores **atómicos** são:

- `"lógico"` para `TRUE` e `FALSE` (o tipo de dados booleano)
- `"integer"` para números inteiros (por exemplo, `2L`, o `L` indica ao R
  que se trata de um número inteiro)
- `"complexo"` para representar números complexos com partes
  reais e imaginárias (por exemplo, `1 + 4i`) e é tudo o que vamos dizer sobre eles
- `"raw"` para bitstreams que não discutiremos mais

Pode verificar o tipo do seu vetor utilizando a função `typeof()`
e introduzindo o seu vetor como argumento.

Os vectores são uma das muitas **estruturas de dados** que o R utiliza. Outros
importantes são listas (`list`), matrizes (`matrix`), quadros de dados
(`data.frame`), factores (`fator`) e matrizes (`array`).

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Vimos que os vectores atómicos podem ser do tipo carácter, numérico (ou
double), inteiro e lógico. Mas o que acontece se tentarmos misturar
estes tipos num único vetor?

:::::::::::::::  solution

## Solução

O R converte-os implicitamente para que sejam todos do mesmo tipo

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

O que é que acontece em cada um destes exemplos? (dica: use `class()` para
verificar o tipo de dados dos seus objetos e digite seus nomes para ver o que acontece):

```{r, eval=TRUE}
num_char <- c(1, 2, 3, "a")
num_logical <- c(1, 2, 3, TRUE, FALSE)
char_logical <- c("a", "b", "c", TRUE)
tricky <- c(1, 2, 3, "4")
```

:::::::::::::::  solution

## Solução

```{r, purl=TRUE}
class(num_char)
num_char
class(num_logical)
num_logical
class(char_logical)
char_logical
class(tricky)
tricky
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Porque é que acha que isso acontece?

:::::::::::::::  solution

## Solução

Os vectores só podem ter um tipo de dados. R tenta converter (coagir)
o conteúdo deste vetor para encontrar um _denominador comum_ que
não perca qualquer informação.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Quantos valores em `combined_logical` são `"TRUE"` (como um carácter)
no seguinte exemplo:

```{r, eval=TRUE}
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
combined_logical <- c(num_logical, char_logical)
```

:::::::::::::::  solution

## Solução

Apenas um. Não há memória de tipos de dados anteriores e a coerção
acontece na primeira vez que o vetor é avaliado. Portanto, o `TRUE`
em `num_logical` é convertido em `1` antes de ser convertido
em `"1"` em `combined_logical`.

```{r}
combined_logical
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Em R, chamamos à conversão de objectos de uma classe para outra classe
_coerção_. Estas conversões ocorrem de acordo com uma hierarquia,
segundo a qual alguns tipos são preferencialmente coagidos a transformarem-se noutros tipos. Pode
desenhar um diagrama que represente a hierarquia da forma como estes dados
tipos são coagidos?

:::::::::::::::  solution

## Solução

lógico → numérico → carácter ← lógico

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, echo=FALSE, eval=FALSE, purl=TRUE}
## We've seen that atomic vectors can be of type character, numeric, integer, and
## logical. But what happens if we try to mix these types in a single
## vector?

## What will happen in each of these examples? (hint: use `class()` to
## check the data type of your object)
num_char <- c(1, 2, 3, "a")

num_logical <- c(1, 2, 3, TRUE)

char_logical <- c("a", "b", "c", TRUE)

tricky <- c(1, 2, 3, "4")

## Why do you think it happens?

## You've probably noticed that objects of different types get
## converted into a single, shared type within a vector. In R, we call
## converting objects from one class into another class
## _coercion_. These conversions happen according to a hierarchy,
## whereby some types get preferentially coerced into other types. Can
## you draw a diagram that represents the hierarchy of how these data
## types are coerced?
```

## Subconjunto de vectores

Se quisermos extrair um ou vários valores de um vetor, temos de
fornecer um ou vários índices entre parênteses rectos. Por exemplo:

```{r, results="show", purl=TRUE}
molecules <- c("dna", "rna", "peptide", "protein")
molecules[2]
molecules[c(3, 2)]
```

Também pode repetir os índices para criar um objeto com mais elementos
do que o original:

```{r, results="show", purl=TRUE}
more_molecules <- molecules[c(1, 2, 3, 2, 1, 4)]
more_molecules
```

Os índices R começam em 1. Linguagens de programação como Fortran, MATLAB,
Julia e R começam a contar em 1, porque é isso que os seres humanos
normalmente fazem. As linguagens da família C (incluindo C++, Java, Perl,
e Python) contam a partir de 0 porque isso é mais simples para os computadores.

Finalmente, também é possível obter todos os elementos de um vetor
, exceto alguns elementos especificados, utilizando índices negativos:

```{r}
molecules ## all molecules
molecules[-1] ## all but the first one
molecules[-c(1, 3)] ## all but 1st/3rd ones
molecules[c(-1, -3)] ## all but 1st/3rd ones
```

## Subconjunto condicional

Outra forma comum de subconjunto é a utilização de um vetor lógico. `TRUE` irá
selecionar o elemento com o mesmo índice, enquanto que `FALSE` não o fará:

```{r, purl=TRUE}
weight_g <- c(21, 34, 39, 54, 55)
weight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]
```

Normalmente, estes vectores lógicos não são digitados à mão, mas são o
resultado de outras funções ou testes lógicos. Por exemplo, se você
quisesse selecionar apenas os valores acima de 50:

```{r, purl=TRUE}
## will return logicals with TRUE for the indices that meet
## the condition
weight_g > 50
## so we can use this to select only the values above 50
weight_g[weight_g > 50]
```

Pode combinar vários testes utilizando `&` (ambas as condições são verdadeiras,
AND) ou `|` (pelo menos uma das condições é verdadeira, OR):

```{r, results="show", purl=TRUE}
weight_g[weight_g < 30 | weight_g > 50]
weight_g[weight_g >= 30 & weight_g == 21]
```

Aqui, `<` stands for "less than", `>` para "maior que", `>=` para
"maior ou igual a", e `==` para "igual a". O sinal duplo de
igualdade `==` é um teste de igualdade numérica entre os lados esquerdo e direito
e não deve ser confundido com o sinal simples `=`, que
efectua a atribuição de variáveis (semelhante a `<-`).

Uma tarefa comum é procurar determinadas cadeias de caracteres num vetor.  Pode
utilizar o operador "or" `|` para testar a igualdade de vários valores, mas
isto pode tornar-se rapidamente aborrecido. A função `%in%` permite-lhe
testar se algum dos elementos de um vetor de pesquisa é encontrado:

```{r, purl=TRUE}
molecules <- c("dna", "rna", "protein", "peptide")
molecules[molecules == "rna" | molecules == "dna"] # returns both rna and dna
molecules %in% c("rna", "dna", "metabolite", "peptide", "glycerol")
molecules[molecules %in% c("rna", "dna", "metabolite", "peptide", "glycerol")]
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Consegue perceber porque é que `"four" > "five"` devolve `TRUE`?

:::::::::::::::  solution

## Solução

```{r}
"four" > "five"
```

Quando utiliza `>` ou `<` em strings, o R compara a sua ordem alfabética.
Aqui `"four"` vem depois de `"five"`, e portanto é _maior do que_
.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Nomes

É possível nomear cada elemento de um vetor. O trecho de código abaixo
mostra um vetor inicial sem quaisquer nomes, como os nomes são definidos e
recuperados.

```{r}
x <- c(1, 5, 3, 5, 10)
names(x) ## no names
names(x) <- c("A", "B", "C", "D", "E")
names(x) ## now we have names
```

Quando um vetor tem nomes, é possível aceder aos elementos pelo seu nome
, para além do seu índice.

```{r}
x[c(1, 3)]
x[c("A", "C")]
```

## Dados em falta

Uma vez que o R foi concebido para analisar conjuntos de dados, inclui o conceito de
dados em falta (o que não é comum noutras linguagens de programação
). Os dados em falta são representados em vectores como `NA`.

Ao efetuar operações sobre números, a maioria das funções devolverá `NA` se
os dados com que está a trabalhar incluírem valores em falta. Esta funcionalidade
faz com que seja mais difícil ignorar os casos em que está a lidar com
dados em falta.  Pode adicionar o argumento `na.rm = TRUE` para calcular
o resultado ignorando os valores em falta.

```{r}
heights <- c(2, 4, 4, NA, 6)
mean(heights)
max(heights)
mean(heights, na.rm = TRUE)
max(heights, na.rm = TRUE)
```

Se os seus dados incluem valores em falta, pode querer familiarizar-se
com as funções `is.na()`, `na.omit()`, e `complete.cases()`. Consulte
para obter exemplos.

```{r}
## Extraia os elementos que não são valores em falta.
heights[!is.na(heights)]

## Devolve o objeto com os casos incompletos removidos.
## O objeto devolvido é um vetor atómico do tipo `"numeric"`
## (ou `"double"`).
na.omit(heights)

## Extrai os elementos que são casos completos.
## O objeto devolvido é um vetor atómico do tipo `"numeric"`
## (ou `"double"`).
heights[complete.cases(heights)]
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

1. Utilizando este vetor de alturas em polegadas, crie um novo vetor com os NAs removidos.

```{r}
alturas <- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)
```

2. Utilize a função `median()` para calcular a mediana do vetor `altura`.
3. Utilize o R para descobrir quantas pessoas no conjunto têm uma altura superior a 67 polegadas.

:::::::::::::::  solution

## Solução

```{r, purl=TRUE}
heights_no_na <- heights[!is.na(heights)]
## or
heights_no_na <- na.omit(heights)
```

```{r, purl=TRUE}
median(heights, na.rm = TRUE)
```

```{r, purl=TRUE}
heights_above_67 <- heights_no_na[heights_no_na > 67]
length(heights_above_67)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Geração de vectores {#sec:genvec}

```{r, echo=FALSE}
set.seed(1)
```

### Construtores

Existem algumas funções para gerar vectores de diferentes tipos. Para
gerar um vetor de números, pode utilizar o construtor `numeric()`
, fornecendo o comprimento do vetor de saída como parâmetro
. Os valores serão inicializados com 0.

```{r, purl=TRUE}
numeric(3)
numeric(10)
```

Note que se pedirmos um vetor de números de comprimento 0, obtemos
exatamente isso:

```{r, purl=TRUE}
numeric(0)
```

Existem construtores semelhantes para caracteres e lógicos, denominados
`character()` e `logical()` respetivamente.

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Quais são as predefinições para vectores de caracteres e lógicos?

:::::::::::::::  solution

## Solução

```{r, purl=TRUE}
character(2) ## the empty character
logical(2)   ## FALSE
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Replicar elementos

A função `rep` permite-lhe repetir um valor um determinado número de
vezes. Se quisermos iniciar um vetor de números de comprimento 5 com
o valor -1, por exemplo, podemos fazer o seguinte:

```{r, purl=TRUE}
rep(-1, 5)
```

Da mesma forma, para gerar um vetor preenchido com valores em falta, que
é muitas vezes uma boa maneira de começar, sem definir pressupostos sobre os dados
a recolher:

```{r, purl=TRUE}
rep(NA, 5)
```

`rep` pode receber vectores de qualquer comprimento como entrada (acima, utilizámos os vectores
de comprimento 1) e de qualquer tipo. Por exemplo, se quisermos repetir os valores 1, 2 e 3 de
cinco vezes, deve fazer o seguinte:

```{r, purl=TRUE}
rep(c(1, 2, 3), 5)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

E se quisermos repetir os valores 1, 2 e 3 cinco vezes, mas
obter cinco 1s, cinco 2s e cinco 3s nessa ordem? Existem duas possibilidades* consulte `?rep` ou `?sort` para obter ajuda.

:::::::::::::::  solution

## Solução

```{r, purl=TRUE}
rep(c(1, 2, 3), each = 5)
sort(rep(c(1, 2, 3), 5))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Geração de sequências

Outra função muito útil é `seq`, para gerar uma sequência de
números. Por exemplo, para gerar uma sequência de números inteiros de 1 a 20
por passos de 2, pode utilizar:

```{r, purl=TRUE}
seq(from = 1, to = 20, by = 2)
```

O valor por defeito de `by` é 1 e, dado que a geração de uma sequência
de um valor para outro com passos de 1 é frequentemente utilizada,
existe um atalho:

```{r, purl=TRUE}
seq(1, 5, 1)
seq(1, 5) ## default by
1:5
```

Para gerar uma sequência de números de 1 a 20 com um comprimento final de 3,
, deve utilizar:

```{r, purl=TRUE}
seq(from = 1, to = 20, length.out = 3)
```

### Amostras aleatórias e permutações

Um último grupo de funções úteis são as que geram dados
aleatórios. O primeiro, `sample`, gera uma permutação aleatória de
outro vetor. Por exemplo, para selecionar uma ordem aleatória para 10 alunos
exame oral, primeiro atribuo a cada aluno um número de 1 a dez (para
exemplo, com base na ordem alfabética do seu nome) e depois:

```{r, purl=TRUE}
sample(1:10)
```

Sem outros argumentos, `sample` retornará uma permutação de todos os
elementos do vetor. Se quiser uma amostra aleatória de um determinado tamanho, eu
definiria este valor como o segundo argumento. Abaixo, faço uma amostragem de 5 letras
aleatórias do alfabeto contidas no vetor `letters` pré-definido:

```{r, purl=TRUE}
sample(letters, 5)
```

Se eu quisesse uma saída maior do que o vetor de entrada, ou ser capaz de
desenhar alguns elementos várias vezes, eu precisaria definir o argumento `replace`
para `TRUE`:

```{r, purl=TRUE}
sample(1:5, 10, replace = TRUE)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafio:

Ao experimentar as funções acima, terá percebido que as amostras
são de facto aleatórias e que não se obtém a mesma permutação
duas vezes. Para ser capaz de reproduzir estes sorteios aleatórios, pode
definir a semente de geração de números aleatórios manualmente com `set.seed()`
antes de desenhar a amostra aleatória.

Teste esta funcionalidade com o seu vizinho. Comece por desenhar duas
permutações aleatórias de `1:10` de forma independente e observe que obtém
resultados diferentes.

Agora defina a semente com, por exemplo, `set.seed(123)` e repita o sorteio aleatório
. Observe que agora obtém os mesmos sorteios aleatórios.

Repita a operação com uma semente diferente.

:::::::::::::::  solution

## Solução

Diferentes permutações

```{r, purl=TRUE}
sample(1:10)
sample(1:10)
```

As mesmas permutações com a semente 123

```{r, purl=TRUE}
set.seed(123)
sample(1:10)
set.seed(123)
sample(1:10)
```

Uma semente diferente

```{r, purl=TRUE}
set.seed(1)
sample(1:10)
set.seed(1)
sample(1:10)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Extrair amostras de uma distribuição normal

A última função que vamos ver é a `rnorm`, que retira uma amostra
aleatória de uma distribuição normal. De seguida, apresentam-se duas distribuições normais com médias 0
e 100 e desvios-padrão 1 e 5, designadas por _N(0, 1)_ e
_N(100, 5)_.

```{r, echo=FALSE, fig.width=12, fig.height=6, fig.cap="Two normal distributions: *N(0, 1)* on the left and *N(100, 5)* on the right."}
par(mfrow = c(1, 2))
plot(density(rnorm(1000)), main = "", sub = "N(0, 1)")
plot(density(rnorm(1000, 100, 5)), main = "", sub = "N(100, 5)")
```

Os três argumentos, `n`, `mean` e `sd`, definem o tamanho da amostra
e os parâmetros da distribuição normal, ou seja, a média
e o seu desvio padrão. As predefinições deste último são 0 e 1.

```{r, purl=TRUE}
rnorm(5)
rnorm(5, 2, 2)
rnorm(5, 100, 5)
```

Agora que aprendemos a escrever scripts e as noções básicas das estruturas de dados do R
, estamos prontos para começar a trabalhar com dados maiores e
aprender sobre estruturas de dados.

:::::::::::::::::::::::::::::::::::::::: keypoints

- Como interagir com o R

::::::::::::::::::::::::::::::::::::::::::::::::::
